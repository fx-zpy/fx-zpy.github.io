{"meta":{"title":"无言","subtitle":"无言","description":"本科 | 前后端 | 网络安全","author":"fx-zpy","url":"http://fx-zpy.github.io","root":"/"},"pages":[{"title":"","date":"2021-10-18T03:23:48.133Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://fx-zpy.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2021-10-01T08:41:10.000Z","updated":"2021-10-02T08:05:34.615Z","comments":true,"path":"404.html","permalink":"http://fx-zpy.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"http://fx-zpy.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-10-01T14:43:14.853Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://fx-zpy.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:09.871Z","comments":true,"path":"about/index.html","permalink":"http://fx-zpy.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:29.685Z","comments":true,"path":"archives/index.html","permalink":"http://fx-zpy.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:47.705Z","comments":true,"path":"categories/index.html","permalink":"http://fx-zpy.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2021-10-02T02:11:28.000Z","updated":"2021-10-02T08:03:07.775Z","comments":true,"path":"census/index.html","permalink":"http://fx-zpy.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:38:37.552Z","comments":true,"path":"contact/index.html","permalink":"http://fx-zpy.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 无言友链信息 博客名称: 无言 博客网址: http://fx-zpy.github.io 博客头像: https://www.wahaotu.com/uploads/allimg/202011/1604238640214543.jpg 博客介绍: a little vegetable chicken"},{"title":"友链","date":"2021-10-02T08:42:10.000Z","updated":"2021-10-02T08:03:53.032Z","comments":true,"path":"friends/index.html","permalink":"http://fx-zpy.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"http://fx-zpy.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-01T08:40:27.000Z","updated":"2021-10-02T08:05:01.978Z","comments":true,"path":"tags/index.html","permalink":"http://fx-zpy.github.io/tags/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-10-01T14:43:14.560Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"http://fx-zpy.github.io/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"http://fx-zpy.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-10-01T14:43:14.557Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"http://fx-zpy.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"http://fx-zpy.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-10-01T14:43:14.566Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-10-01T14:43:14.568Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-10-01T14:43:14.569Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-10-01T14:43:14.570Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-10-01T14:43:14.572Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-10-01T14:43:14.576Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-10-01T14:43:14.577Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-10-01T14:43:14.573Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-10-01T14:43:14.578Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode几道dp中等题","slug":"lc","date":"2021-10-11T02:16:46.000Z","updated":"2021-10-18T02:17:15.050Z","comments":true,"path":"posts/db0f04bc.html","link":"","permalink":"http://fx-zpy.github.io/posts/db0f04bc.html","excerpt":"","text":"摆动序列题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 分析这道题和之前所做的合唱队形有点像，但是这不是求解最大增序列，而是增减交替的序列，首选还是一个一个分析，如果所给序列的长度只有一，那么返回的子序列的长度也是一，如果序列的长度超过一个，就可以使用两个变量up,down来计算上升和下降的个数，这里的增加数目是在对方的基础上进行的，因为要计算最长的子序列而不是最长增序列或者减序列。代码如下。 int wiggleMaxLength(int* nums, int numsSize){ if(numsSize&lt;2) return numsSize; int up=1; int down=1; for(int i=1;i&lt;numsSize;i++){ if(nums[i]&gt;nums[i-1]){ up=down+1; } else if(nums[i]&lt;nums[i-1]){ down=up+1; } } return (up&gt;down)?up:down; } 零钱兑换题目描述给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。 分析这是一个很经典的背包问题，背包是固定的，物品是多个的，我们只要求把背包填满就好了，这里使用动态规划，或者DFS加剪枝都可以，我使用的是DP，至于为什么不用DFS，因为不会我写完了看题解才发现可以使用这种方法，这里可以使用一个数组dp来接收局部最优解。dp[0]初始化0，其他初始化足够大的数，因为求最少的数目，我这里初始化为100000，只需要满足测试用例的要求即可。代码如下。 int coinChange(int* coins, int coinsSize, int amount){ int* dp=(int *)malloc((amount+1)*sizeof(int)); dp[0]=0; for(int i=1;i&lt;=amount;i++){ dp[i]=100000; } for(int i=1;i&lt;=amount;i++){ for(int j=0;j&lt;coinsSize;j++){ if(coins[j]&lt;=i){ dp[i]=dp[i]&lt;dp[i-coins[j]]+1?dp[i]:dp[i-coins[j]]+1; } } } return dp[amount]&gt;amount?-1:dp[amount]; } 这里也copy一下其他人的题解，关于使用DFS和BFS来求解的。实属强者，LeetCode的算法大佬太多了，膜拜。 以下为DFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: coins.sort(reverse=True) self.res = float(\"inf\") def dfs(i, num, amount): if amount == 0: self.res = min(self.res, num) return for j in range(i, len(coins)): # 剩下的最大值都不够凑出来了 if (self.res - num) * coins[j] &lt; amount: break if coins[j] &gt; amount: continue dfs(j, num + 1, amount - coins[j]) for i in range(len(coins)): dfs(i, 0, amount) return self.res if self.res != float(\"inf\") else -1 以下为BFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: from collections import deque queue = deque([amount]) step = 0 visited = set() while queue: n = len(queue) for _ in range(n): tmp = queue.pop() if tmp == 0: return step for coin in coins: if tmp &gt;= coin and tmp - coin not in visited: visited.add(tmp - coin) queue.appendleft(tmp - coin) step += 1 return -1 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 分析这里需要注意审题， 我刚开始读题不仔细，以为是分解成两个正整数，兴致勃勃的开始做题，不到两分钟代码就写好了，心里不禁想到，中等题就这，结果不小心瞟到了题目的要求，至少，顿时麻了，赶紧删掉了自己刚写好的代码，并且内心说了句，私密马赛。是我愚蠢了，那么重新分析，既然是至少，那么就不限制分解成2个了，但是想了想，不太好解，如果自底向上，往上也不好分析，因为这个不像之前的蜜蜂和走楼梯，后一个的问题只依赖于前一个和前两个问题的最优解。这里看了一下别人的思路，发现宝藏，一个人的思路是这样，根据数学的规律来解这道题，可以大大简化题目的复杂度，求解y=(n/x)^x的最大解，并且最大解的时候x的值为多少，最后算出来x=e的时候y最大，所以只要多分解出e得到的成绩就会越大，但是题目要求为正整数，所以从2和3中选择，这里随便取一个n实验一下，比如12=2+2+2+2+2+2=3+3+3+3,2^6=64,3^4=81，很显然，3比2具有更大的乘积，所以就将所给的n尽量分解成3,能够得到最大的乘积。代码如下。 int integerBreak(int n){ int a=1; if(n==2){ return 1; }else if(n==3){ return 2; }else if(n==4){ return 4; }else{ while(n&gt;4){ n-=3; a*=3; } return a*n; } } 总结dp的思想还是局部最优解的推进，但是可以使用数学知识来简化问题。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"}],"author":"fx-zpy"},{"title":"go实现简单群聊服务器","slug":"goqunliao","date":"2021-10-07T08:44:46.000Z","updated":"2021-10-07T09:20:34.244Z","comments":true,"path":"posts/4b92e806.html","link":"","permalink":"http://fx-zpy.github.io/posts/4b92e806.html","excerpt":"","text":"TCP群聊服务器实现之前实现了TCP服务器，可以和客户端通信，这次进行了扩展，将多个客户端的通信集中到一起，形成群聊系统，服务器的主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) type client struct { c chan string //发送数据的管道 name string //姓名 addr string //地址 } var onlinemap map[string]client //保存在线用户 var message = make(chan string) func manager() { onlinemap = make(map[string]client) for { msg := &lt;-message //如果message通道没有消息就阻塞 for _, cli := range onlinemap { cli.c &lt;- msg //遍历map，给每个成员都发送信息，相当于广播 } } } func writemsgtoclient(cli client, ac net.Conn) { for msg := range cli.c { ac.Write([]byte(msg + \"\\n\")) } } func makemsg(cli client, msg string) (buf string) { buf = \"[\" + cli.addr + \"]\" + cli.name + \":\" + msg return } func dispose(ac net.Conn) { //获取客户端的网络地址 cliaddr := ac.RemoteAddr().String() //创建一个结构体默认用户名和网络地址一样 cli := client{make(chan string), cliaddr, cliaddr} onlinemap[cliaddr] = cli //将结构体添加到map //新开一个协程，给当前客户发送信息 go writemsgtoclient(cli, ac) message &lt;- makemsg(cli, \"login\") cli.c &lt;- makemsg(cli, \"I am here\") isexit := make(chan bool) //新建协程，接受用户发送的数据 go func() { buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) if len == 0 { isexit &lt;- true fmt.Println(\"err=\", err) return } msg := string(buffer[:len-1]) if msg == \"who\" { ac.Write([]byte(\"user list:\\n\")) for _, tmp := range onlinemap { msg = tmp.addr + \":\" + tmp.name + \"\\n\" ac.Write([]byte(msg)) } } else if strings.Count(msg, \"\") &gt;= 8 &amp;&amp; msg[:6] == \"rename\" { name := strings.Split(msg, \"|\")[1] cli.name = name onlinemap[cliaddr] = cli fmt.Println(\"rename successfully\") } else { message &lt;- makemsg(cli, msg) } } }() for { select { case &lt;-isexit: delete(onlinemap, cliaddr) message &lt;- makemsg(cli, \"logout\") } } //开启循环，一直开启协程 } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //开一个协程，转发信息 go manager() //主协程，循环阻塞等待用户连接 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) continue } go dispose(ac) } } 本次服务器开启的端口依旧是本地的4000端口，每个客户端可以修改自己的名称，默认的名称是地址，同时上线和退出都会有login和logout的提示。如果输入的是who那么就会给出当前在线的用户列表。 测试这里我单开一个窗口作为旁观者可以观看到其他人发的信息，俗称摸鱼窥屏怪。其他的我开了三个用户，分别重新命名为zpy,xsg,hs他们进行聊天。 这边hs的视角忘记截图了，不过有前两个人的视角应该就够了，这个群聊做的很简单，界面布局也没有什么设计，包括敏感词汇屏蔽和@功能实现都还没有做，后续随缘更新功能和界面，这次只是为了能够实现聊天的主题功能。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"go学习笔记之tcp服务器","slug":"gotcp","date":"2021-10-05T07:43:46.000Z","updated":"2021-10-07T08:48:56.092Z","comments":true,"path":"posts/db7cd9a0.html","link":"","permalink":"http://fx-zpy.github.io/posts/db7cd9a0.html","excerpt":"","text":"单程TCP服务器这是只接受来自客户端的一次通信就停止的服务器，也是后面并发服务器的基础知识，服务器的构成代码是用go语言编写，如下。 package main import ( \"fmt\" \"net\" ) func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } buffer := make([]byte, 4096) //分配一个4096字节的缓冲区来接收用户的数据 len, err := ac.Read(buffer) //返回数据长度和错误信息 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data=\", string(buffer[:len])) defer ac.Close() } 这里使用net里面的函数listen对本地4000端口进行监听，为啥是4000端口，其实端口号无所谓，4000端口是每次更新博客的时候本地调试的端口，因为经常能看色图博客，所以使用该端口，这里接受信息的缓冲区的大小为4096，也就是4kb，来自4000端口发送的数据大小不能超过该大小，使用的时候不会报错，但是服务器端只会截取规定缓冲区的大小，我实验过使用的大小为4的缓冲区来接受超过10个字节的数据，最后只是截取到前四个字节的数据就结束了。这里使用netcat下的一个可执行程序nc来进行数据的发送。分配好端口号之后就发送数据，同时服务器端接受到数据之后就停止了，因为本身就是一个单程的服务器。 并发服务器并发服务器支持对多个客户端进行数据的传送与接收。 服务器端服务器端的代码在之前单程服务器的基础上进行改进，增加协程来处理与客户端的交互。主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) func Dispose(ac net.Conn) { add := ac.RemoteAddr().String() //处理客户端的端口号 fmt.Println(add, \" connected successfully\") defer ac.Close() buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) //接收客户端数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from client is\", string(buffer[:len])) //打印接收到数据 if string(buffer[:len-1]) == \"exit\" { return } ret := strings.ReplaceAll(string(buffer[:len]), \"sb\", \"**\") //将数据中的不文明词汇和谐，这里只处理了sb这个经常出现的词汇 ac.Write([]byte(ret)) //返回数据 } } func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } go Dispose(ac) } } 这里通过协程对每一个请求的客户端的数据都能进行处理，在实际工作中服务器端接收到客户端的数据之后可以进行很多处理，我这里仅仅进行了对敏感词汇sb的和谐，并把数据重新发回给客户端。上述代码的停止条件是输入exit，这里的处理仅仅适用于nc测试，因为nc测试中我们输入了exit回车之后换行也一并输入了进来，所以上述代码中判断条件为string(buffer[:len-1]) == “exit”，自编客户端程序进行测试的时候由于编写者的不同，数据的处理可能不同。需要根据实际情况进行修改。 测试nc这里我开了两个进程来测试服务器端能否实现并发，结果发现可以。输入exit客户端也能顺利的结束进程。 客户端程序这里也可以自编客户端程序进行测试，主动连接对应的端口号，对其进行数据的交互。这里我写了一个客户端程序进行测试，也是使用go语言进行编写。 package main import ( \"fmt\" \"net\" \"os\" ) func main() { //设置连接的端口号 conn, err := net.Dial(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer conn.Close() //开启协程，接收服务器端的回复 go func() { buffer := make([]byte, 4096) for { len, err := conn.Read(buffer) //读取数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from server is\", string(buffer[:len])) // } }() //给服务器端发送数据 se := make([]byte, 4096) for { len, err := os.Stdin.Read(se) //从键盘读取内容 if err != nil { fmt.Println(\"err=\", err) return } conn.Write(se[:len]) //将输入的信息发送给服务器 } } 测试截图如下 注意这里输入exit不能退出，因为客户端输入的时候输入回车，字符串后面会跟着两个字符，回车\\r，换行\\n，所以服务器端需要进行修改才能退出客户端程序，即将服务器端的判断条件改为string(buffer[:len-1]) == “exit”。但是这样感觉不方便，可以在测试的客户端输入条件判断一下，为exit就退出。当然这些都是小细节。 总结单程和并发区别在于是否使用了协程，本次测试也用到了脑残nc和客户端程序。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"合唱队形&&过河卒","slug":"dp1","date":"2021-10-04T08:28:18.000Z","updated":"2021-10-06T01:49:32.389Z","comments":true,"path":"posts/9c48d863.html","link":"","permalink":"http://fx-zpy.github.io/posts/9c48d863.html","excerpt":"","text":"合唱队形题目描述N位同学站成一排，音乐老师要请其中的(N?K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1,2,…,K，他们的身高分别为T1,T2,…,TK。身高满足T1&lt;…Ti+1&gt;…&gt;TK(1≤i≤K)。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。输入有两行，第一行是一个整数N(2≤N≤100)，表示同学的总数。第二行有N个整数，用空格分隔，第i个整数Ti(130≤Ti≤230)是第i位同学的身高(厘米)。输出最少需要同学出列的个数。 思路第一次错误尝试第一次我的思路是每次标定一个人，从他开始依次向左和右进行筛选，如果有后一个比前一个高的情况出现，就判定前一个得出队列，当然我还没有意识到问题的严重性，连调试都没做就去提交了，结果可想而知，10个测试点就过了一个，以下是第一次的代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int min=150,flag,a; int t[100] = { 0 }; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); for (int j = 0; j &lt; 100; j++) { flag = 0; a = t[j]; for (int i = j; i &lt; 99; i++) { if (a &lt; t[i + 1])flag++; else a = t[i + 1]; } a = t[j]; for (int i = j; i &gt; 0; i--) { if (a &lt; t[i - 1])flag++; else a = t[i - 1]; } if (flag &lt; min)min = flag; } printf(\"%d\\n\", min); } 错误以后我自己进行了分析，发现，如果在我选定的那一个人的右边第一位是他右边最低的，而从右边第二位开始依次递减，那么我的算法就把从第二位开始的人全部踢出去了这显然不符合最少的规则，正确的是只需要把右边第一位踢出去就可以了。 第二次尝试经过分析以后，我开始转换思路，依旧选定一个人做参照，将合唱队分成两个部分，然后分别从最左边和最右边向中间求最多人的增序列，这样踢出去的人就最少，两个数组分别存储左右的最大增序列的人数，但是注意，被当做参照物的那个人算了两次，所以要减去1。代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int uflag,dflag; int t[100] = { 0 }; int u[100], d[100]; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); u[0] = 1; d[n - 1] = 1; for (int i = 1; i &lt; n; i++) { uflag = 1; for (int j = 0; j &lt; i; j++) { if (t[i] &gt; t[j])uflag = uflag &gt; u[j] + 1 ? uflag : u[j] + 1; } u[i] = uflag; } for (int i = n - 2; i &gt;= 0; i--) { dflag = 1; for (int j = n - 1; j &gt; i; j--) { if (t[i] &gt; t[j])dflag = dflag &gt; d[j] + 1 ? dflag : d[j] + 1; } d[i] = dflag; } int max = 0; for (int i = 0; i &lt; n; i++) { if (u[i] + d[i] - 1 &gt; max) max = u[i] + d[i] - 1; } printf(\"%d\\n\",n-max); } 成功通过了OJ。 过河卒题目描述棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点(0,0)、B点(n,m)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。输入一行四个正整数，分别表示B点坐标和马的坐标。坐标不超过（20,20）。输出一个整数，表示所有的路径条数。 思路思路就是没有思路题目给我的第一印象就是好难啊，我把题目给的一个示例在草稿纸上人工走了一遍，但是没有思路，如果没有这匹该死的马，那将简单多了，就像之前的小蜜蜂和爬楼梯一样，但是可惜没有，一个马最多限制了九个点无法通过，有可能马的位置离边境较近，9个点中有部分不在（0,0）和（n,m）为顶点组成的矩形里面，我的初始想法是先求出所有的路径，然后把路径中包含马的控制点的路径排除，这个想法我没去实现，因为我在大脑里面过了一下，预感时空限制可能通不过OJ，于是打开了谷歌，搜索过河卒（bushi。看了别人的思路之后感觉豁然开朗，路径条数的dp还是我之前说的那样，每到每一个点的个数是上面点和左边点的个数之和，这里我用了一个二维数组，初始化都为0，将马的控制点设置为-1（之后再调整为0），每个数组元素的值就是到该点的路径条数之和，再用dp到(n,m)。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int x, y, m, n; int long long path[25][25] = { 0 }; int mx[8] = { -2,-2,-1,-1,1,1,2,2 }; int my[8] = { 1,-1,2,-2,2,-2,1,-1 }; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;x, &amp;y); getchar(); n += 1; m += 1; x += 1; y += 1; for (int i = 0; i &lt; 8; i++) { if (x + mx[i] &gt;= 1 &amp;&amp; x + mx[i] &lt;= n &amp;&amp; y + my[i] &gt;= 1 &amp;&amp; y + my[i] &lt;= m)path[x + mx[i]][y + my[i]] = -1; } path[x][y] = -1; path[1][0] = 1; for (int i = 1; i&lt;= n; i++) { for (int j = 1; j &lt;=m; j++) { if (path[i][j] == -1)path[i][j] = 0; else path[i][j] = path[i][j - 1] + path[i - 1][j]; } } printf(\"%lld\\n\", path[n][m]); return 0; } 这么简单的题目我都能卡住，我太菜了o(╥﹏╥)o，CSP危。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"},{"title":"逆向简单题之dotnetcrack","slug":"pwn-dotnetcrack","date":"2021-10-03T02:36:08.000Z","updated":"2021-10-03T03:04:48.367Z","comments":true,"path":"posts/a651b15e.html","link":"","permalink":"http://fx-zpy.github.io/posts/a651b15e.html","excerpt":"","text":"题目背景这道题是我的一个同学转了安全以后发给我让我帮忙做一下，但是其实本来我也没有接触多少逆向的知识，但是还是打算尝试一下，题目是dotnetcrack，打开可执行程序以后，弹出一个弹窗如下 尝试输入一串字符串，发现报错。 学习了一下这方面的知识以后，也是使用了一款反编译工具ILSpy将程序进行反编译，找到判断的关键代码， 如图可以发现其判断的语句是”2yyUjXprc1+2TwAbbVU6eQ==” == Encode(textBox1.Text)，显然，正确的字符串进行某种规则加密后的密文为2yyUjXprc1+2TwAbbVU6eQ==。 解法一：投机取巧已知判断条件之后，可以修改判断条件为!=，因为随机输入一串字符串，相等的概率极低，那么相反，不相等的概率极高，修改之后，随便输入只要不是正确的明文就可以弹出恭喜的弹窗，实验了一下，因为ILSpy不能直接修改代码，所以讲代码保存出来进行修改， 保存之后重新编译该文件，这样随便输入就可以弹出正确的弹窗了。 解法二：再次投机取巧由于解法一虽然可以弹出正确的弹窗，但是正确的明文却还是不知道，所以这次还是投机取巧的办法，但是能够获取明文，这里针对加密函数编写了一段解密函数。 public string Decode(string data) { string result; byte[] byte1; try { byte1 = Convert.FromBase64String(\"2yyUjXprc1+2TwAbbVU6eQ==\"); byte[] bytes = Encoding.ASCII.GetBytes(\"gctf{got\"); byte[] bytes2 = Encoding.ASCII.GetBytes(\"2niceday}\"); DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateDecryptor(bytes, bytes2), CryptoStreamMode.Write); cryptoStream.Write(byte1, 0, byte1.Length); cryptoStream.FlushFinalBlock(); System.Text.Encoding encoding = System.Text.Encoding.UTF8; result = encoding.GetString(memoryStream.ToArray()); } catch { result = \"\"; } return result; } 利用该解密函数正确的密文进行解密得到正确的明文，这次不修改判断逻辑，修改错误的输出为解密正确的密文得到的明文。 private void button1_Click(object sender, EventArgs e) { if (\"2yyUjXprc1+2TwAbbVU6eQ==\" == Encode(textBox1.Text)) { MessageBox.Show(\"Congratulation~!!\"); } else { MessageBox.Show(Decode(textBox1.Text)); } } textBox1.Text就是我们输入的内容，那么我们输入密文，弹出的就是正确的明文了 这样就可以得到明文内容了，是H0lyTru3EasY，这里再把明文输入就可以得到正确的提示了。 解法三：直接解密因为上个学期也学过密码学原理这门课，虽然我学的不咋地，但是还是尝试读懂了加密函数，发现这里采用了DES的CBC加密模式，并且使用了Base64进行编码，那么可以直接利用网上的解密工具，密钥从代码中可以得知是gctf{got，偏移值是2niceday}，直接进行解密也能获得明文。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}],"author":"fx-zpy"},{"title":"第一篇博客&&动态规划","slug":"dp0","date":"2021-10-02T03:43:08.000Z","updated":"2021-10-07T09:19:42.262Z","comments":true,"path":"posts/62cb98ee.html","link":"","permalink":"http://fx-zpy.github.io/posts/62cb98ee.html","excerpt":"","text":"数字三角形题目描述观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。第一个行一个正整数r,表示行的数目。后面每行为这个数字金字塔特定行包含的整数。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 思路动态规划有两种路线，这道题我选择了从底向上，用一个数组来存储每一个点的局部最大和，从倒数第二层开始，一直到顶层，最后得到的数组的第一位数就是最大值，代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int r; int num[1001] = { 0 }; scanf(\"%d\", &amp;r); getchar(); int array[1001][1001] = { 0 }; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; i || j == i; j++) { scanf(\"%d\", &amp;array[i][j]); } getchar(); } for (int j = 0; j &lt; r - 1; j++) { if (array[r-1][j] &gt; array[r-1][j + 1]) num[j] = array[r-2][j] + array[r-1][j]; else num[j] = array[r-2][j] + array[r-1][j + 1]; } for (int i = r - 3; i &gt; 0||i==0; i--) { for (int j = 0; j &lt; i || j == i; j++) { if (num[j] &gt; num[j + 1]) num[j] = num[j] + array[i][j]; else num[j] = num[j + 1] + array[i][j]; } } printf(\"%d\", num[0]); return 0; } 最后可以通过OJ平台，但是在vs调试的时候发现数组栈溢出了。 母牛的故事题目描述有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 思路通过列举前几年的关系，发现规律，前4年的数量和年份相同，第五年的时候，第二年的两头牛是成年母牛可以生殖了，所以应该是上一年的数量加上上四年的数量，因为题目给的年份不多，所以用一个55位的数组存储每一年的数量，再根据输入n的值，直接输出数组[n]。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int n; scanf(\"%d\", &amp;n); getchar(); int num[55] = { 0 }; for (int i = 1; i &lt; 55; i++) { if (i &gt; 0 &amp;&amp; i &lt; 5)num[i] = i; else num[i] = num[i-1] + num[i - 3]; } while (n != 0) { printf(\"%d\\n\", num[n]); scanf(\"%d\", &amp;n); getchar(); } return 0; } 一只小蜜蜂题目描述有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。对于每一个测试样例，输出蜜蜂从蜂房a到蜂房b的可能路线数。 思路分析可知，a比b小，从a到b直接不好分析，从b开始，能直接到b的有b-1和b-2那么路线数就是两者之和，再分析b-1和b-2，发现规律一致，也是题目便利，数据都不大，可以用数组来表示可能路线数，这里的数组下标是两者的距离。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a, b; long long int k[50] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 50; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d%d\", &amp;a, &amp;b); getchar(); printf(\"%lld\\n\", k[b - a]); } return 0; } 这里有个坑，初始我定义k的时候类型是int，但是OJ报错，查了一下资料才发现数据越界，于是改成lli就行了。 爬楼梯题目描述有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数，对于每个测试实例，请输出不同走法的数量。 思路这道题目读完以后不难发现，和小蜜蜂基本一致，只不过a固定是1罢了，数据范围还小了，直接上代码。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a; long long int k[41] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 41; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d\", &amp;a); getchar(); printf(\"%lld\\n\", k[a-1]); } return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"},{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"},{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}]}