{"meta":{"title":"无言","subtitle":"无言","description":"本科 | 前后端 | 网络安全","author":"fx-zpy","url":"http://fx-zpy.github.io","root":"/"},"pages":[{"title":"404","date":"2021-10-01T08:41:10.000Z","updated":"2021-10-02T08:05:34.615Z","comments":true,"path":"404.html","permalink":"http://fx-zpy.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-10-18T03:23:48.133Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://fx-zpy.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-10-26T02:58:50.309Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://fx-zpy.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"http://fx-zpy.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:09.871Z","comments":true,"path":"about/index.html","permalink":"http://fx-zpy.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:29.685Z","comments":true,"path":"archives/index.html","permalink":"http://fx-zpy.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:47.705Z","comments":true,"path":"categories/index.html","permalink":"http://fx-zpy.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2021-10-02T02:11:28.000Z","updated":"2021-10-02T08:03:07.775Z","comments":true,"path":"census/index.html","permalink":"http://fx-zpy.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:38:37.552Z","comments":true,"path":"contact/index.html","permalink":"http://fx-zpy.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 无言友链信息 博客名称: 无言 博客网址: http://fx-zpy.github.io 博客头像: https://www.wahaotu.com/uploads/allimg/202011/1604238640214543.jpg 博客介绍: a little vegetable chicken"},{"title":"友链","date":"2021-10-02T08:42:10.000Z","updated":"2021-10-02T08:03:53.032Z","comments":true,"path":"friends/index.html","permalink":"http://fx-zpy.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"http://fx-zpy.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-01T08:40:27.000Z","updated":"2021-10-02T08:05:01.978Z","comments":true,"path":"tags/index.html","permalink":"http://fx-zpy.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-10-01T14:43:14.557Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"http://fx-zpy.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"开心一刻","date":"2021-10-20T05:10:10.000Z","updated":"2021-10-20T05:10:01.767Z","comments":true,"path":"List/movies/index.html","permalink":"http://fx-zpy.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"http://fx-zpy.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"回忆青春","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-08T04:23:24.485Z","comments":true,"path":"List/music/index.html","permalink":"http://fx-zpy.github.io/List/music/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-10-01T14:43:14.566Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-10-01T14:43:14.560Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-10-01T14:43:14.568Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-10-01T14:43:14.572Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-10-01T14:43:14.569Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-10-01T14:43:14.573Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-10-01T14:43:14.577Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-10-01T14:43:14.578Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-10-01T14:43:14.570Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-10-01T14:43:14.576Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"c++知识总结","slug":"c++knowledge","date":"2021-11-14T10:29:08.000Z","updated":"2021-11-16T06:53:39.658Z","comments":true,"path":"posts/bbf4e5b.html","link":"","permalink":"http://fx-zpy.github.io/posts/bbf4e5b.html","excerpt":"","text":"本文来源于C++ 教程 | 菜鸟教程 (runoob.com)，由于C++和C有很多的重合点，所以本文仅记录两者不同点或者C++中比较重要的点 C++基础知识基本概念 类：类可以定义为描述对象行为/状态的模板/蓝图 对象：对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例 方法：从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作 即时变量：每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的 using namespace std:告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念 C++区分大小写 C++关键字C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com) wchar_t:宽字符型（来源于typedef short int wchar_t,就是把short int命名为wchar_t） 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中 转义序列 含义 \\ \\ 字符 ' ‘ 字符 \" “ 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 类型限定符限制的变量的特性 const:const 类型的对象在程序执行期间不能被修改改变 volatile:修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率 restrict:由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前(auto自从C++17开始就不再是存储类，register被弃用) static：static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享 extern:extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候 mutable:mutable 说明符仅适用于类的对象,它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改 thread_local:使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义 运算符的优先级 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 Lambda表达式：Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似 基本形式 [capture](parameters)-&gt;return-type{body} 例如 [](int x, int y){ return x &lt; y ; } 没有返回值的时候 [capture](parameters){body} 例如 []{ ++global_x; } ------------------------------------------------------------------------- 在Lambda表达式内可以访问当前作用域的变量，需要引用的时候通过前面的[capture]来调用，下面是各种引用的区别 [] // 没有定义任何变量。使用未定义变量会引发错误。 [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。 [&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入 [this]() { this-&gt;someFunc(); }(); 数学运算：使用需要包含函数头文件，以下为一些常用的函数 序号 函数 &amp; 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 随机数生成 rand()生成的是伪随机数，虽然随机但是有规律可寻，但是使用srand()先设置种子就能真的随机，这个种子一般是时间，例如设置种子srand( (unsigned)time( NULL ) )， setw()：C++ setw() 函数 | 菜鸟教程 (runoob.com) 引用：引用变量是一个别名，它是某一个已经存在的变量的另一个名字，一旦把引用初始化为某个变量，就可以使用该引用名称或者变量名来指向变量 int&amp; r = i; double&amp; s = d; 在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 \"r 是一个初始化为 i 的整型引用\"，第二个声明可以读作 \"s 是一个初始化为 d 的 double 型引用\" ------------------------------------------------------------------------- 示例程序 #include &lt;iostream&gt; using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; \"Value of i : \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"Value of i reference : \" &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; \"Value of d : \" &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; \"Value of d reference : \" &lt;&lt; s &lt;&lt; endl; return 0; } ------------------------------------------------------------------------- 程序运行结果 Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象 引用必须在创建时被初始化。指针可以在任何时间被初始化 日期和时间：使用需要包含头文件 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。结构类型 tm 把日期和时间以 C 结构的形式保存 struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; 序号 函数 &amp; 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 基本输入输出 C++ 基本的输入输出 | 菜鸟教程 (runoob.com)有两篇笔记值得一看 重要I/O库头文件 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输入输出流 输出：预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 #include &lt;iostream&gt; using namespace std; int main( ) { char str[] = \"Hello C++\"; cout &lt;&lt; \"Value of str is : \" &lt;&lt; str &lt;&lt; endl; } C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符，也可以替换成”\\n” 输入：预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的 #include &lt;iostream&gt; using namespace std; int main( ) { char name[50]; cout &lt;&lt; \"请输入您的名称： \"; cin &gt;&gt; name; cout &lt;&lt; \"您的名称是： \" &lt;&lt; name &lt;&lt; endl; } C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据,例如cin &gt;&gt; name &gt;&gt; age; 标准错误流：预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 &lt;&lt; 结合使用的 #include &lt;iostream&gt; using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr &lt;&lt; \"Error message : \" &lt;&lt; str &lt;&lt; endl; } 本质上和cout差不多 标准日志流：预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。clog 也是与流插入运算符 &lt;&lt; 结合使用的 #include &lt;iostream&gt; using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog &lt;&lt; \"Error message : \" &lt;&lt; str &lt;&lt; endl; } 和cin差不多 在小示例中无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出 面向对象 类和对象 定义：C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员，定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作 示例 #include &lt;iostream&gt; using namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double get(void); void set( double len, double bre, double hei ); }; // 成员函数定义 double Box::get(void) { return length * breadth * height; } void Box::set( double len, double bre, double hei) { length = len; breadth = bre; height = hei; } int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 详述 Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // box 1 的体积 volume = Box1.height * Box1.length * Box1.breadth; cout &lt;&lt; \"Box1 的体积：\" &lt;&lt; volume &lt;&lt;endl; // box 2 的体积 volume = Box2.height * Box2.length * Box2.breadth; cout &lt;&lt; \"Box2 的体积：\" &lt;&lt; volume &lt;&lt;endl; // box 3 详述 Box3.set(16.0, 8.0, 12.0); volume = Box3.get(); cout &lt;&lt; \"Box3 的体积：\" &lt;&lt; volume &lt;&lt;endl; return 0; } 详解 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 &amp; 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 继承 定义：面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类 例如 // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; 这里派生类或者其他语言里面叫子类继承基类或者其他语言里面的父类所用的方式是class 派生类：访问修饰符 基类，访问修饰符是 public、protected 或 private 其中的一个，如果未定义，则默认是private 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 派生类可以继承基类的所有方法但是不包括以下几点 基类的构造函数、析构函数和拷贝构造函数 基类的重载运算符 基类的友元函数 多继承 一个子类可以有多个父类，继承多个父类的特性 class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,… { &lt;派生类类体&gt; }; --------------------------------------------------------------------- 例如 #include &lt;iostream&gt; using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout &lt;&lt; \"Total area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl; // 输出总花费 cout &lt;&lt; \"Total paint cost: $\" &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0; } 重载运算符和重载函数：C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策 函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数 #include &lt;iostream&gt; using namespace std; class printData { public: void print(int i) { cout &lt;&lt; \"整数为: \" &lt;&lt; i &lt;&lt; endl; } void print(double f) { cout &lt;&lt; \"浮点数为: \" &lt;&lt; f &lt;&lt; endl; } void print(char c[]) { cout &lt;&lt; \"字符串为: \" &lt;&lt; c &lt;&lt; endl; } }; int main(void) { printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = \"Hello C++\"; pd.print(c); return 0; } --------------------------------------------------------------------- 整数为: 5 浮点数为: 500.263 字符串为: Hello C++ 运算符重载 您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表 Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示： Box operator+(const Box&amp;, const Box&amp;); 例如 #include &lt;iostream&gt; using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) { Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout &lt;&lt; \"Volume of Box1 : \" &lt;&lt; volume &lt;&lt;endl; // Box2 的体积 volume = Box2.getVolume(); cout &lt;&lt; \"Volume of Box2 : \" &lt;&lt; volume &lt;&lt;endl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout &lt;&lt; \"Volume of Box3 : \" &lt;&lt; volume &lt;&lt;endl; return 0; } --------------------------------------------------------------------- Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 以下为可重载的运算符 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，**-&gt;(成员访问)，,(逗号)，[]**(下标) 以下为不可重载的运算符 .：成员访问运算符 **.\\*, -&gt;\\***：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 运算符重载实例 序号 运算符和实例 1 一元运算符重载 2 二元运算符重载 3 关系运算符重载 4 输入/输出运算符重载 5 ++ 和 – 运算符重载 6 赋值运算符重载 7 函数调用运算符 () 重载 8 下标运算符 [] 重载 9 类成员访问运算符 -&gt; 重载 多态：如果基类和派生类里面定义了相同的方法，在调用的时候该方法是基类的方法，这是静态多态，例如下面这个例子 #include &lt;iostream&gt; using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout &lt;&lt; \"Parent class area :\" &lt;&lt;endl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout &lt;&lt; \"Rectangle class area :\" &lt;&lt;endl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout &lt;&lt; \"Triangle class area :\" &lt;&lt;endl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = &amp;rec; // 调用矩形的求面积函数 area shape-&gt;area(); // 存储三角形的地址 shape = &amp;tri; // 调用三角形的求面积函数 area shape-&gt;area(); return 0; } ------------------------------------------------------------------------- Parent class area : Parent class area : 可以看到结果都是基类里面的方法，如果想使用派生类的方法可以在派生类的方法前面加入一个virture，表示这是一个虚函数,如果你想在基类中定义虚函数，让派生类可以重新定义，这个时候基类中不能有实际意义的实现，需要用到纯虚函数，即让它为空值，如果是int就为0，char为’0‘，指针为NULL class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; };","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://fx-zpy.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fx-zpy.github.io/tags/C/"},{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"author":"fx-zpy"},{"title":"数据库知识体系","slug":"databaseknowledge","date":"2021-11-11T10:29:08.000Z","updated":"2021-11-12T13:36:49.127Z","comments":true,"path":"posts/d43b3954.html","link":"","permalink":"http://fx-zpy.github.io/posts/d43b3954.html","excerpt":"","text":"第一章 绪论 文件系统和数据库的区别 数据结构性 文件系统把数据组织成相互独立的数据文件，实现了记录内的结构性，但整体无结构 l数据库系统实现整体数据的结构化，也是数据库系统与文件系统的本质区别 数据独立性 文件系统中的文件是为某一特定应用服务的，当要修改数据的逻辑结构时，必须修改应用程序，修改文件结构的定义，数据和程序之间缺乏独立性 数据库系统中，通过DBMS的两级映象实现了数据的物理独立性和逻辑独立性，把数据的定义从程序中分离出去，减少了应用程序的维护和修改 数据共享 数据库系统的共享度高。系统现有用户和程序可以共享数据库中的数据；当系统扩充时还可以开发出新的用户和程序来共享原有数据库资源；多用户或或程序可以在同一时刻共享同一数据 文件系统实现以文件为单位的数据共享 数据冗余 在文件系统中，数据冗余度大，浪费存储空间，容易造成数据的不一致 数据库系统中，数据是面向整个系统，数据可以被多个用户、多个应用共享使用，减少了数据冗余 数据库管理系统（DBMS）是位于用户与操作系统之间的一层数据管理软件，是一个大型的复杂的软件系统，用于科学地组织和存储数据、高效地获取和维护数据 ACID：数据库事务正确执行的四个基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 数据库管理系统的功能 数据定义功能 提供数据定义语言（DDL） 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据库操作功能 提供数据操纵语言（DML） 实现对数据库的基本操作 （查询、插入、删除和修改） 数据库的事务管理和运行管理 数据库在建立、运行和维护时由数据库管理系统统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库的建立和维护功能 数据库初始数据的装载和转换 数据库转储、恢复功能 数据库的重组织 性能监视、分析等 其他功能 数据库管理系统与网络中其它软件系统的通信 数据库管理系统系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统（DBS）组成 数据库 DBMS 应用程序 数据库管理员 数据库类型 文件型数据库—文件型数据库可以认为是最简单的一种数据库模型，其实现非常简单，就是读写一个简单的文件，分隔符多样，文件类型可以是CSV、TSV或者是JSON文件。数据直接以人类可读的形式呈现，程序也比较容易解析。文件型数据库其实现非常简单，同样地这也限制了它的使用。例如在并发和并行的场景下，文件型数据库就表现的不是那么友好，且读取性能不是那么优秀，单点查询和范围查找的需要从头遍历整个文件 层次数据库—层次数据库模型诞生于1960年代，是文件型数据的下一个形态。层次数据库模型类似于一个树状结构，每条记录有且仅有一个父节点，类似于下图。层次数据库是人们第一次尝试去思考和处理复杂数据，在一定程度上提升了文件型数据库的一些特定数据读取方式的性能，但是层次数据库是基于树状的模型，访问层次数据库类似于遍历链表，很难实现对复杂数据的读取 网状数据库—网状数据库也诞生于1960年代。数据系统语言会议（（Conference on Data Systems Languages,CODASYL）的委员会标准化了网状数据库模型，因此网状数据库模型也被称为 CODASYL 模型。网状数据库进一步发展了层次数据库模型，解决了层次数据库有且仅有一个父节点的问题。网状数据库模型的子节点可以拥有多个父节点，同时这也带来了更高的复杂性。和层次数据库模型一样，网状数据库模型的查询和更新都需要遍历链表，给开发带了无尽的难度，这使得网状数据库模型逐渐没落。毕竟能使用网状数据库模型的地方 关系型数据库—关系型数据库模型诞生于1960年代，是现存的数据库模型中活得最久、生命力最旺盛、使用的最为广泛的数据模型。关系型数据库模型在刚提出来时，并不受到待见，但是在二十世纪八十年代成为了绝大多数人的首选数据库。关系型数据库模型基于关系代数，它认为：数据可以被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。换句话说，一个关系（表）只是一个元 组（行）的集合。关系型数据库模型解决了层次数据库模型无法表达多对多关系的能力；在关系型数据库中，读取数据时不再需要像访问链表一样去访问数据，开发者可以随意读取表中的任意行和列；并且关系型数据库引入了外键的概念，使得表和表之间可以轻易的关联起来•适用于关系型数据库的查询语言是SQL。SQL作为一个图灵完备的语言，已经不仅仅局限于关系型数据库，而是成为数据库领域中当之无愧的王者。SQL的核心在于查询优化器，由查询优化器自动决定SQL的哪些部分以哪个顺序执行，以及使用什么索引。总的来说，关系型数据库模型以其强大的灵活性和适应力成为了开发者的首选数据库模型 数据模型 概念数据模型：是对现实世界的抽象 逻辑数据模型 物理数据模型 三级模式结构 关系数据库中的模式一定是关系的，在该层可见的实体是关系的表和关系的操作符 外模式也是关系的，它的内容是来自模式 内模式不是关系的，它是数据的物理存储方式 第二章 关系数据库关系代数 关系代数 关系模型源于数学，关系是由元组构成的集合，可以通过关系的运算来表达查询要求 关系代数是关系数据库的基础 关系代数是关系操作语言的一种传统的表示方式，它是一种抽象的查询语言 关系代数的运算可分为两大类 传统的集合运算：广义笛卡尔积运算、并、交和差运算 专门的关系运算：选择、投影、连接和除运算 关系代数运算符 专门的关系运算 选择 在关系R中选择满足给定条件的诸元组 σF(R) = {t|t∈R∧F(t)=’true’} F：选择条件，是一个逻辑表达式，取值为“true”或“false”基本形式为：F(t) = X1 θ Y1θ表示比较运算符，它可以是＞，≥，＜，≤，＝ 或 ≠ 选择运算是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算 投影 从R中选择出若干属性列组成新的关系 ∏A(R) = { t[A] | t ∈R } A：R中的属性列投影操作主要是从列的角度进行运算 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） 连接 连接也称为θ连接,连接运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组 A和B：分别为R和S上度数相等且可比的属性组，θ：比较运算符 连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 等值连接：θ为“＝”的连接运算 自然连接：一种特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组在结果中把重复的属性列去掉，假设R和S具有相同的属性组B 等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接 除运算 经常用于求解“查询…全部的/所以的…”问题前提条件：给定关系R(A1,A2,…,An)为n度（目）关系，关系S(B1，B2,…,Bm)为m度关系。如果可以进行关系R与关系S 的除运算，当且仅当：属性集(B1，B2,…,Bm)是属性集(A1,A2,…,An)的真子集，即m&lt;n。定义：关系S和关系R的除运算也是一个关系，记作：R ÷ S, 分两部分来定义。 先定义R ÷ S结果的属性应有哪些？设属性集{C1,C2,…,Ck} = {A1,A2,…,An} – {B1,B2,…,Bm} , 则有 k=n-m, R ÷ S结果关系是一个k(n-m)度关系，由{C1,C2,…,Ck} 属性组成。 再定义R ÷ S的元组怎样形成？再设关系R(&lt;a1,a2,…,an&gt;)和关系S(&lt; b1,b2,…,bm &gt;),那么R÷S结果关系为元组&lt; c1,c2,…,ck &gt;的集合，元组 &lt; c1,c2,…,ck &gt;满足下述条件：R÷S中&lt; c1,c2,…,ck &gt;与S中的每一个元组&lt; b1,b2,…,bm &gt;组合形成的一个元组都是R中的某一个元组&lt;a1,a2,…,an&gt;。（其中 a1,a2,…,an， b1,b2,…,bm ， c1,c2,…,ck 分别为 A1,…,An,B1,…,Bm,C1,…,Ck的值） ​ R ÷ S = {t | t∈∏R-S (R) ∧∀u∈S(tu∈R)} 符号表示 设关系模式是R(A1,A2,….,An) R: 是关系模式R(A1, A2, …,An)的一个关系 t∈ R : 表示t是R的一个元组 t[Ai] : 表示元组t中相应于Ai的一个分量(元组 t对应字段或属性Ai的值) 若 A = {Ai1, Ai2, …,Aik}, 其中Ai1，Ai2, …,Aik 是A1，A2,…,An中的一部分，则A称为属性列或属性组 t[A] = (t[Ai1], t[Ai2] …,t[Aik]) 表示元组t在属性列A上诸分量的集合 Ā 则表示{A1, A2, …,An}中去掉{Ai1, Ai2, …,Aik}后剩余的属性组 R 为n 目关系，S为m目关系。 tr ∈R, ts ∈ S, 称为元组连接，且是一个n+m列的元组，前n个分量是R中的一个n元组，后m个分量是S中的一个m分量 给定一个关系R(X,Y),X和Y为属性组。当t[X] = x 时，x在R中的象集(Image Set)为：Yx = {t[Y]|t∈R, t[X] = x}它表示R中属性组X上值为x的诸元组在Y上分量的集合 关系模型 域：是一组具有相同数据类型值的集合，域指的是属性的取值范围,也就是不同元组对同一属性的取值所限定的范围例如，整数、正整数、实数、大于等于0且小于等于100的正整数、{0,1,2,3,4}等都可以是域 基数：一个域允许的不同取值个数称为这个域的基数 属性：每列取一个名字 键 超键：超键是表中字段的任何组合，可以唯一地标识该表中的每个记录 候选键：候选键是超键的子集。候选键是唯一标识表中每个记录的单个字段或字段的最小组合。字段的最小组合将候选键与超键区分开。每个表必须至少具有一个候选键，但同时可以具有多个候选键 候选键必须包含唯一值，不能包含空值，包含最少数量的字段来确保唯一性，必须唯一标识表中的每个记录 主键：是最适合用作表的主要参考键的候选键。顾名思义，它是表引用的主键，并在整个数据库中用于帮助与其他表建立关系。与任何候选键一样，主键必须包含唯一值，绝不能为null，并且唯一标识表中的每个记录 每个表都必须有主键每个记录必须为其主键有一个值从候选键中选择主键时，选择一个简单键 外键：通常是一个表中的主键，它在另一个表中作为字段出现，其中第一个表与第二个表有关系。换句话说，如果我们有一个表A，该表的主键X链接到表B，其中X是B中的一个字段，那么X将是B中的外键。 替代键：一个表可能有一个或多个主键选择。如前所述，它们被统称为候选键。选择一个作为主键。未选择的键称为替代键 唯一键：唯一键是表的一个或多个字段/列的集合，它们唯一地标识数据库表中的记录。就像主键一样，但是它只能接受一个空值，并且不能有重复值 主键与唯一键的区别：主键不能接受空值，而唯一键可以接受一个空值主键是聚簇索引，并且数据库表中的数据按照聚簇索引的顺序进行物理组织。唯一键是唯一的非聚集索引一个表中只能有一个主键。而一个表中有多个唯一键 关系的限定和扩充 限定：无限关系在数据库系统中是无意义的，限定关系数据模型中的关系必须是有限集合 扩充：通过为关系的每个列附加一个属性名的方法取消关系属性的有序性 数学上 （计算机，信息）≠ (信息，计算机)数据库上 （计算机，信息）= (信息，计算机) 关系数据库：所有关系的集合 型：关系数据库的型称为关系数据库模式，是对关系数据库的描述 值：关系数据库的值是这些关系模式在某些时刻对应的关系的集合，通常称作关系数据库 关系的完整性约束 实体完整性：主码不能取空值 参照完整性：一个关系的外键必须是另一个关系的主键，也可以是空 用户定义的完整性：指对关系中每个属性的取值作一个限制(或称为约束)的具体定义 第三章 SQLDDL语言 SQL（结构化查询语言）是一种非过程化的语言，使用者只需要说明“做什么”而不需要说明“怎么做”，是关系数据库的标准语言，通用功能强 SQL集定义、操作、查询和控制为一体 SQL表的数据类型 SQL表语句的基本语法 创建表 CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] … [,&lt;表级完整性约束条件&gt; ] ); 例如：创建一个课程的表 CREATE TABLE Course ( Cno CHAR(4) PRIMARY KEY, //主键 Cname CHAR(40), Cpno CHAR(4), Ccredit SMALLINT， FOREIGN KEY (Cpno) REFERENCES Course(Cno) //外键，Course(Cno)为被参照表（被参照列） ); 修改表 ALTER TABLE &lt;表名&gt; [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ] [ ADD &lt;表级完整性约束&gt;] [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ] [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ] [ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] - ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件 - DROP COLUMN子句用于删除表中的列如果指定了CASCADE短语，则自动删除引用了该列的其他对象如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列 - DROP CONSTRAINT子句用于删除指定的完整性约束条件 - ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型 - 删除列: ALTER TABLE 表名 DROP COLUMN 列名 增加列: ALTER TABLE 表名 ADD COLUMN 列名 属性 【约束】 修改列类型: ALTER TABLE 表名 CHANGE COLUMN 列名 新列名 【新属性】 重命名列: ALTER TABLE 表名字 CHANGE COLUMN 列名 新列名 重命名表: ALTER TABLE 表名 RENAME TO 表新名 删除表中主键: ALTER TABLE 表名 DROP PRIMARY KEY 添加主键: ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY (添加列) 添加索引: ALTER TABLE 表名 ADD INDEX 索引名 (列名) 修改列的属性: ALTER TABLE 表名 MODIFY COLUMN 列名 新属性 删除表 DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］ RESTRICT：删除表是有限制的 欲删除的基本表不能被其他表的约束所引用； 如果存在依赖该表的对象，则此表不能被删除CASCADE：删除该表没有限制 在删除基本表的同时，相关的依赖对象（表定义、数据、索引、视图、触发器等）一起删除 SQL索引 创建索引 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…) &lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔 &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 删除索引 DROP INDEX &lt;索引名&gt; SQL视图 定义：视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化 优点 简化用户操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当的利用视图可以更清晰地表达查询 创建视图 CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…) AS &lt;子查询&gt; [WITH CHECK OPTION]; 子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现 WITH CHECK OPTION：对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式） 删除视图 DROP VIEW &lt;视图名&gt;[CASCADE] 该语句从数据字典中删除指定的视图定义如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 更新视图 插入 INSERT INTO IS_Student VALUES(‘201215129’,’赵新’,20) 修改 UPDATE IS_Student SET Sname= ‘刘辰’ WHERE Sno= ‘201215122’ 删除 DELETE FROM IS_Student WHERE Sno= ' 201215129 ' 单表和多表查询 SQL查询 SELECT [&lt;SELECT选项&gt;] &lt;字段列表[字段别名] [表达式] [常量] [(SELECT子句)] &gt; FROM 子句 [WHERE子句] [GROUP BY子句 ] [HAVING 子句] [ORDER BY 子句] [LIMIT 子句]; SELECT选项：ALL(缺省)和DISTINCT SELECT子句：指定要显示的属性列 FROM子句：指定查询对象（基本表或视图） WHERE子句：指定查询条件 GROUP BY子句：对查询结果按指定列的值分组 该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。 HAVING短语：只有满足指定条件的组才予以输出 ORDER BY子句：对查询结果表按指定列值的升序或降序排序 LIMIT子句：用于限制查询结果返回的数量 SQL TOP子句 TOP TOP 子句用于规定要返回的记录的数目num。对于拥有数千条记录的大型表来说 TOP 子句是非常有用的 例如：SELECT TOP 50 PERCENT * FROM Persons 并非所有的数据库都支持TOP子句 SQL alias（别名） 为什么要用别名 数据库中往往过长的表名或列名会对我们数据统计,显示（中文）造成困扰 书写比较方便 别名怎么定义和使用 Select 字段 AS 别名 Select 字段 别名 Select 别名=字段 From student as s From student s From s=student 这一部分的SQL语句平时用多了自然就熟练了，基础知识真没啥好说的","categories":[{"name":"数据库","slug":"数据库","permalink":"http://fx-zpy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"database","slug":"database","permalink":"http://fx-zpy.github.io/tags/database/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（三）","slug":"winnet2","date":"2021-11-11T08:00:08.000Z","updated":"2021-11-11T10:29:24.173Z","comments":true,"path":"posts/ed71a2a6.html","link":"","permalink":"http://fx-zpy.github.io/posts/ed71a2a6.html","excerpt":"","text":"四、网络层数据平面","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（二）","slug":"winnet1","date":"2021-11-10T04:43:08.000Z","updated":"2021-11-11T10:29:09.080Z","comments":true,"path":"posts/a06f01f4.html","link":"","permalink":"http://fx-zpy.github.io/posts/a06f01f4.html","excerpt":"","text":"二、应用层知识点 网络应用的架构有三种：C/S模型（客户端/服务器）、对等网（Peer-to-Peer，P2P）、混合体系（C/S+P2P) C/S:服务器总是打开拥有一个固定的地址并且是一个缩放的数据中心，客户端可以和服务器通信，但不能与客户端通信，且通信可能是间歇性的，客户端拥有动态的IP地址 P2P：客户端之间是对等的，可以通信，提供服务也享受服务，结点之间的连接是间歇性的地址也是变化的 网络应用进程使用套接字来唯一确定 套接字包含主机地址和端口号 主机地址：标识该网络应用进程运行在网上哪一台主机上，通常使用32位的ip地址来进行标识。 端口地址：在该主机上标识该网络应用进程，通常使用16位的端口号来进行标识 运输层传输协议主要有两个：TCP和UDP TCP 面向连接：在客户端和服务器端进程之间需要进行连接 可靠传输：在发送和接受进程之间 流量控制：发送数据的速度不会超过接受的速度 拥塞控制：当网络超负荷时，减缓发送速度 目前缺陷：不提供最小带宽承诺和实时性传输 UDP 不可靠的数据传输 不需要建立连接 没有流量控制和拥塞控制 不提供实时传输和最小带宽承诺 应用层协议 HTTP 无状态的：服务器不保留任何访问过的请求信息 保留过去的请求信息会造成隐患，如果浏览器或者服务器崩溃那么各自的状态视图就会发生分歧，需要重新核对 HTTP采用TCP来作为运输协议步骤如下 客户端启动TCP连接（创建套接字）到服务器，端口80 服务器接受来自客户端的TCP连接 http报文（应用层协议报文）在浏览器和web服务器之间进行交换 关闭TCP连接 HTTP传输模式 1.0—非持久连接：每个TCP连接仅仅传输一个请求报文和响应报文，即每个TCP连接在浏览器发送一个对象之后就会关闭，不会持续连接 1.1—持久连接：服务器发送响应报文以后，TCP连接不会立即断开，继续保持这连接状态，知道长时间没有对象的运输才进行断开，减少了对服务器的套接字的占用，提高了服务器的负载能力 非流水线方式：一个对象传输完成才能传输下一个对象 流水线方式：一次性的发送所有的请求，慢慢接受 一般的HTTP请求报文格式 典型的HTTP请求报文格式 HTTP请求行支持的方法 GET（1.0/1.1）：向服务器请求指定的URL的对象 POST（1.0/1.1）：用于向服务器提交表单数据也可以请求一个web页面 可以不使用POST方法而使用GET方法发送表单数据来获取新的WEB页面，例如搜索引擎 HEAD（1.0/1.1）：请求服务器返回一个响应报文，但是报文中不包含请求对象，该方法常常用来进行故障追踪 PUT（1.1）：上传的文件放在实体主体字段中，目标路径由URL字段标明 DELETE（1.1）：删除URL字段中指定的文件 HTTP响应报文的一般格式 HTTP响应报文具体例子 常见的HTTP响应状态码和短语 200—OK：请求成功，被请求的对象在报文中 301—Moved Permanently：被请求的对象移动过，新的位置在报文中有说明 400—Bad Request：服务器不懂请求报文 404—Not Found：服务器上找不到请求对象，色情网站经常这样 505—HTTP Version Not Supported:服务器不支持请求报文使用的HTTP协议版本 Cookie web站点为什么使用cookie 限制用户的访问 把内容和用户的身份关联起来 cookie技术的组成部分 HTTP请求和响应报文里面各有一个cookie的首部行 用户的端系统上保留了一个cookie文件，由浏览器负责管理 web站点有一个后端数据库 cookie工作流程 cookie和私密性 cookie允许网站获取用户的信息包括用户在一些站点用于登录的个人信息 搜索引擎可以通过cookie和重定向技术获取更多的信息 其他广告公司也能从中获取用户的信息 SMTP 全称简单邮件传输协议，使用TCP可靠的传送邮件报文，端口为25 直接传输 传输的三个阶段 握手（打招呼） 报文传输 结束 命令：ASCll文本 响应：状态码和状态短语 邮件报文必须使用7-bit ASCll表示，非ASCll也可以使用MIME扩展来实现转换 非ASCll的MIME扩展 MIME和SMTP的关系 邮件访问协议：邮件已经传送到目的服务器上了，接收方通过邮件访问协议来读取邮件 POP3（第三版的邮局协议） 特许阶段：用户代理发送用户名和口令（明文）来鉴别用户 事务处理阶段：用户代理取回报文，并且可以对报文做删除标记或者删除这些标记 更新阶段：客户发出quit命令之后，删除第二步被标记为删除的报文，然后结束POP3会话 POP3会话没有状态，用户也无法在邮件服务器上对自己的邮件进行重组织，只能将邮件先下载到本地再进行重组织 IMAP（因特网邮件访问协议） 将所有的邮件都保存在服务器上 允许用户在服务器上组织自己的邮件目录 维护了IMAP会话的用户信息：目录名和报文ID与目录名之间的映射关系 HTTP：基于web的电子邮件在浏览器和邮件服务器之间传输使用的是HTTP协议，但是邮件服务器之间的传输依旧是SMTP DNS：用于IP地址和域名之间的转换 DNS是一个分布式的数据库，由很多台DNS服务器按照层次结构组织起来 DNS运行在端到端系统上，且使用的是UDP协议（53号端口）进行报文传输，因此DNS是应用层协议 以C/S模式工作 DNS解析过程例子 DNS实现 三、运输层知识点总结 运输层为不同主机上运行的应用进程之间提供逻辑通信 运输层协议发送方将应用数据划分成报文段，交给网络层，接受方把报文段重组成应用数据，交付给应用层 网络层是不同主机的通信，而运输层是应用进程之间的通信 多路复用和多路分解 使用UDP套接字的时候，数据报中需要指定目的IP地址和目的端口，使用TCP套接字的时候，则还需要指定源IP地址和源端口号 UDP 发送方 从应用进程得到数据 附加上多路分解和复用所需的源和目的端口号以及差错检测信息，形成报文段 递交给网络层，尽力的传送给接收方的主机（我发了，收不收的到得看人品） 接收方 从网络层接受报文段（数据报） 根据目的端口号，将数据交付给相应的应用进程 UDP通信不需要握手，是无连接的，而且无需维护连接状态，段首部开销比TCP小，TCP20字节，UDP只需要8个字节，而且无拥塞控制，可以按需随时发送 UDP的校验和=报文段的所有16比特字的和再进行反码转换，接收方将所有16比特字和校验和相加，结果如果不是全1，说明有错误，是全1，也有可能出错。 Rdt1.0:经完全可靠信道的可靠数据传输（底层信号非常可靠，无比特差错，无分组丢失） Rdt2.0:经具有比特差错信道的可靠数据传输（肯定确认、否定确认），这种基于重传机制的可靠数据传输协议被称为自动重传请求（ARQ）协议，在ARQ协议中有三种协议功能来处理比特差错的情况：差错检测 、接收方反馈 、重传，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。因此Rdt2.0这样的协议被称为停等协议 rdt2.0未考虑ACK和NAK分组受损的情况，这也是2.1诞生的原因 Rdt2.1：如果ACK\\NAK受损 可能导致冗余 为了处理冗余发送方对每个分组增加序列号 如果ACK\\NAK受损，发送方重传当前分组，接收方丢弃冗余分组 因为除了对的都是错的，那么可以去掉NAK，只传ACK，这样可以节省空间，这也是2.2的原理 Rdt2.2 无NAK协议，代替NAK，接收方对最后正确接收的分组发送ACK rdt2.x解决了流量控制问题，以及比特出错的情况，但是丢包情况却没有解决，这也是rdt3.0的任务 Rdt3.0是具有比特差错和丢包信道的可靠数据传输，为解决丢包问题，发送方等待ACK一段合理的时间，需要倒数计时器来解决这个问题 停等操作使得rdt3.0的效率十分低下，可以使用流水线技术来解决 流水线技术中分组丢失之后如何重传 GBN（Go-Back-N）协议：其后分组全部重传 累计ACK：收到ACK（n），则n以及之前的分组都到了 若滑动窗口大小为n,则发送方只能连续发送n个数据包，同时，窗口中未被确认的分组数不能超过n 对所有的已发送但未确认的分组统一设置一个定时器，从一次流水的最“老”分组开始计时 超时（n）,重传分组n和窗口中所有序号大于n的分组 GBN滑动窗口大小 发送端&lt;=2^k-1 接收端=1 如果收到重复的分组就丢弃重发ACK，如果有分组丢失，但是后面的分组到了，也是将这一部分丢弃，然后重发按序到达的最高序号分组的ACK SR（选择重传）协议：仅重传该分组 发送方 从上层收到ACK（n）,若n在[sendbase,sendbase+N-1]范围内，则标记n已经被接受，如果n=sendbase，则将窗口基序号推到下一个未确定序号 超时（n）:为每一个分组定义计时器，如果n超时，则重传并且重置定时器 接收方 收到n在[sendbase,sendbase+N-1]范围内，发送ACK（n） 如果收到分组不是连续的，先进行缓存 按序分组 接收方和发送方窗口都不能超过2^(k-1) TCP报文首部结构 源端口和目的端口各占2字节 序号字段占4字节，TCP连接中传送的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节在整个报文字节流中的序号 确认号字段占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 和之前不同，之前收到x号分组就发ACK（x），这里收到x号分组就发ACK（x+1）表示期待收到x+1号分组 首部长度占4bits，它指示以32bit的字为单位的TCP首部长度，若选项字段为空，TCP首部典型长度为20字节 保留字段占6bits，该字段是以后所用，目前应该置为0 URG（紧急比特）=1时，表示紧急指针字段有效，它告诉系统此报文中有紧急数据，应该尽快传送（一般不使用） ACK（确认比特）=1时，确认号字段有效，=0无效 PSH（推送比特）=1时，TCP尽快交付该报文，不等整个缓存都填满再交付 RST (复位比特)=1时，表示TCP连接中出现严重差错，必须释放连接，再重新建立连接 SYN（同步比特）=1时，这是一个连接请求或者连接接受报文 FIN（终止比特）=1时，表明此报文段的数据全部发送完毕，要求释放运输连接 窗口字段占两个字节，用来控制对方发送的数据量，单位是字节，TCP连接的一端根据设置的缓存空间大小确定自己的接受窗口大小，然后通知对方来确定对方的发送窗口的上限 校验和占两个字节，该字段检验的范围包括首部和数据两个部分，所以计算的时候，需要在TCP报文段的前面加上12字节的伪首部 紧急指针字段占2个字节，该字段指出在本报文段中的紧急数据的最后一个字号的序号 选项字段，长度可变，TCP只规定了一种选项，即最大报文长度（MSS），MSS是TCP报文中数据段的最大长度。 填充字段为了使整个首部长度是4字节的整数倍 RTT=往返时延，SampleRTT=样本RTT（忽略重传），EstimatedRTT=样本RTT的均值，DevRTT=EstimatedRTT和SampleRTT的偏差 EstimatedRTT=（1-a）* EstimatedRTT+a * SampleRTT，参考值a=0.125 DevRTT=（1-b）* DevRTT+b * |SampleRTT-EstimatedRTT|,参考值b=0.25 第一次计算的时候DevRTT=0.5*SampleRTT 产生TCP ACK的建议 接受方事件 TCP接收方动作 所期望序号的报文段按序到达，所有在期望序号及其以前的数据都已经被确认 延迟的ACK，对另一个按序报文段的到达最多等待500ms，如果下一个按序报文段还没有到达，就发送一个ACK 所期望序号的报文段按序到达，另一个按序报文段等待发送ACK 立即发送单个累计ACK，以确认两个按序报文段 比期望序号大的失序报文段到达，检测出数据流中的间隔 立即发送冗余ACK，指明下一个期待字节的序号 能部分或者完全填充接收数据间隔的报文段到达 假如该报文段起始于间隔的低端，则立即发送ACK 快速重传：接收到重复的ACK就重传，不一定非要等到规定的时间间隔 TCP通过三次握手建立连接 拥塞控制的方法 网络辅助的拥塞控制 直接网络反馈：路由器以阻塞分组的形式通知发送方网络阻塞 由接收方的网络反馈：路由器标识从发送方到接收方分组中某个字段来指示拥塞产生，由接收方通知发送方 端到端拥塞控制（目前TCP使用该方法） 网络层不为拥塞控制提供任何帮助和支持 端系统通过对网络行为（丢包或者时延增加）的观测来判断网络是否发生拥塞","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（一）","slug":"winnet","date":"2021-11-08T02:43:08.000Z","updated":"2021-11-11T10:28:56.957Z","comments":true,"path":"posts/de1fcd2b.html","link":"","permalink":"http://fx-zpy.github.io/posts/de1fcd2b.html","excerpt":"","text":"这里将所学的计算机网络的 课程的知识进行归纳总结，预计一篇完不成，所以分篇进行归纳总结，这是自顶向下第七版的第一章，主要是从总体介绍一下计算机网络的模型和接下来会接触到的知识。 一、计算机网络和因特网相关问题和知识点总体概述 什么是因特网 具体构成：基本硬件和软件组件， 分布式应用服务 端系统是主机，通过通信链路和分组交换机连接到一起，通过因特网服务提供商（ISP）接入因特网 主机分为客户机和服务器 当今因特网内，最著名的分组交换机为路由器和链路层交换机 端系统、分组交换机和其他部件都需要运行一系列协议，其中最重要的两个协议是TCP（传输控制协议）和IP（网际协议）。因特网的主要协议统称为TCP/IP 因特网的分布式应用程序运行在端系统上，分许交换机只是用来加速端系统之间数据交换的，不运行应用程序 端系统之间的数据交互通过套接字接口来对应交互 协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输/接收或其他事件方面采取的动作 接入网指将端系统物理连接到其边缘路由器的网络，而边缘路由器是端系统到任意其他的远程端系统的路径上的第一台路由器。接入网分为以下几种 家庭接入：DSL（数字用户线）、电缆、FTTH（光纤到户）、拨号、卫星 企业（和家庭）接入：以太网、WiFi 广域无线接入：3G（出书那年4G还没出)、LTE 物理媒体分为导引型和非导引型媒体，导引型是电波沿着固体媒体前行，例如光缆、双绞铜线、同轴电缆，非导引型是电波在空气或者外层空间中传播，例如无线局域网和数字卫星频道 通过网络链路和交换机移动数据有两种基本方法，电路交换和分组交换 分组交换：端系统之间彼此交换报文，报文比较长，源端将长报文划分为较小的数据块，每一块成为分组（packet） 输入端的机制是存储转发传输，即在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组 分组交换由于其到端时延是不可预测的，所以不适合实时服务。 分组交换提供了比电路交换更好的带宽共享；他比电路交换更简单，更有效，实现成本更低 分组交换时延类型 节点处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分，除此之外，还需要检查比特级差错。高速路由器的处理时延通常是微秒或更低的数量级 排队时延：在队列中，当分组在链路上等待传输时，产生排队时延。影响排队时延的因素有：到达该队列的流量强度和性值。实际的排队时延通常在毫秒到微秒级 传输时延：传输距离/传输速度，得到的是传输时间。这个时间就是将所有的比特推向链路所需要的时间。实际的传输时延通常在毫秒到微秒级 传播时延：当一个比特被推进链路后，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间时传播时延 调制/编码时延：量级为几十毫秒。 节点总时延：以上时延之和 电路交换 频分复用 时分复用 电路交换的效率较低，因为在静默的时候专用电路是空闲的。 流量强度：La/R,L是每个分组的长度，单位为比特，a是分组到达队列的平均速率，La是单位时间到达队列的分组总长，R是传输速率，流量强度&gt;1会造成拥塞，所以一般设计的时候流量强度不能大于1 丢包：由于队列容量有限，在队列满了以后，路由器会丢弃队尾若干分组 瞬时吞吐量：某一时刻目的主机接收到文件的速率 平均吞吐量：文件总大小/接收文件总用时 协议分层 应用层：应用层是网络应用程序及其应用层协议存留的地方。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文 HTTP（为web文档提供了请求和传送） SMTP（提供了电子邮件报文的传输） FTP（提供两个端系统之间的文件传送） 表示层（七层模型） 会话层（七层模型） 运输层：运输层提供了在应用程序端点之间传送应用报文的服务 TCP:向它的应用程序提供了面向连接的服务，这种服务包括了应用层报文向目的地取得确保传递和流量控制（即发送方和接收方的速率匹配）。并将长报文划分为短报文，并提供拥塞控制机制 UDP：向它的应用程序提供无连接服务。这是一种不提供不必要的服务的服务，不提供可靠性，没有流量控制，也没有拥塞控制 网络层：因特网的网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。源主机中的因特网运输层协议（TCP/UDP）向网络层递交运输层报文段和目的地址 IP协议：定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议 选路协议：数据报根据该路由从源传输到目的地 链路层：为了将分组从一个节点移动到路径的下一个节点，网络层必须依靠链路层的服务。特别是在每个节点，网络层将数据报传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据报上传给网络层。我们将链路层分组称为帧。链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素 以太网、wifi、点对点协议（PPP） 物理层：物理层的任务是将每一帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议与链路相关，并与链路的实际传输媒体（双绞铜线，单模光纤）有关 封装：报文从一层到另一层，另一层会加上该层的首部信息，将报文进行封装然后传送给下一层，应用层报文和运输层首部信息共同构成了运输层报文段 ，运输层报文段封装了应用层报文。运输层向网络层传递报文段，网络层增加了源和目的端系统地址等网络层首部信息，形成了网络层数据报。链路层增加自己的链路层首部信息并创建了链路层帧。每一层分组具有两种类型的字段：首部字段和有效载荷字段","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"LeetCode几道dp中等题","slug":"lc","date":"2021-10-11T02:16:46.000Z","updated":"2021-10-20T13:01:01.693Z","comments":true,"path":"posts/db0f04bc.html","link":"","permalink":"http://fx-zpy.github.io/posts/db0f04bc.html","excerpt":"","text":"摆动序列题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 分析这道题和之前所做的合唱队形有点像，但是这不是求解最大增序列，而是增减交替的序列，首选还是一个一个分析，如果所给序列的长度只有一，那么返回的子序列的长度也是一，如果序列的长度超过一个，就可以使用两个变量up,down来计算上升和下降的个数，这里的增加数目是在对方的基础上进行的，因为要计算最长的子序列而不是最长增序列或者减序列。代码如下。 int wiggleMaxLength(int* nums, int numsSize){ if(numsSize&lt;2) return numsSize; int up=1; int down=1; for(int i=1;i&lt;numsSize;i++){ if(nums[i]&gt;nums[i-1]){ up=down+1; } else if(nums[i]&lt;nums[i-1]){ down=up+1; } } return (up&gt;down)?up:down; } 零钱兑换题目描述给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。 分析这是一个很经典的背包问题，背包是固定的，物品是多个的，我们只要求把背包填满就好了，这里使用动态规划，或者DFS加剪枝都可以，我使用的是DP，至于为什么不用DFS，因为不会我写完了看题解才发现可以使用这种方法，这里可以使用一个数组dp来接收局部最优解。dp[0]初始化0，其他初始化足够大的数，因为求最少的数目，我这里初始化为100000，只需要满足测试用例的要求即可。代码如下。 int coinChange(int* coins, int coinsSize, int amount){ int* dp=(int *)malloc((amount+1)*sizeof(int)); dp[0]=0; for(int i=1;i&lt;=amount;i++){ dp[i]=100000; } for(int i=1;i&lt;=amount;i++){ for(int j=0;j&lt;coinsSize;j++){ if(coins[j]&lt;=i){ dp[i]=dp[i]&lt;dp[i-coins[j]]+1?dp[i]:dp[i-coins[j]]+1; } } } return dp[amount]&gt;amount?-1:dp[amount]; } 这里也copy一下其他人的题解，关于使用DFS和BFS来求解的。实属强者，LeetCode的算法大佬太多了，膜拜。 以下为DFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: coins.sort(reverse=True) self.res = float(\"inf\") def dfs(i, num, amount): if amount == 0: self.res = min(self.res, num) return for j in range(i, len(coins)): # 剩下的最大值都不够凑出来了 if (self.res - num) * coins[j] &lt; amount: break if coins[j] &gt; amount: continue dfs(j, num + 1, amount - coins[j]) for i in range(len(coins)): dfs(i, 0, amount) return self.res if self.res != float(\"inf\") else -1 以下为BFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: from collections import deque queue = deque([amount]) step = 0 visited = set() while queue: n = len(queue) for _ in range(n): tmp = queue.pop() if tmp == 0: return step for coin in coins: if tmp &gt;= coin and tmp - coin not in visited: visited.add(tmp - coin) queue.appendleft(tmp - coin) step += 1 return -1 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 分析这里需要注意审题， 我刚开始读题不仔细，以为是分解成两个正整数，兴致勃勃的开始做题，不到两分钟代码就写好了，心里不禁想到，中等题就这，结果不小心瞟到了题目的要求，至少，顿时麻了，赶紧删掉了自己刚写好的代码，并且内心说了句，私密马赛。是我愚蠢了，那么重新分析，既然是至少，那么就不限制分解成2个了，但是想了想，不太好解，如果自底向上，往上也不好分析，因为这个不像之前的蜜蜂和走楼梯，后一个的问题只依赖于前一个和前两个问题的最优解。这里看了一下别人的思路，发现宝藏，一个人的思路是这样，根据数学的规律来解这道题，可以大大简化题目的复杂度，求解y=(n/x)^x的最大解，并且最大解的时候x的值为多少，最后算出来x=e的时候y最大，所以只要多分解出e得到的成绩就会越大，但是题目要求为正整数，所以从2和3中选择，这里随便取一个n实验一下，比如12=2+2+2+2+2+2=3+3+3+3,2^6=64,3^4=81，很显然，3比2具有更大的乘积，所以就将所给的n尽量分解成3,能够得到最大的乘积。代码如下。 int integerBreak(int n){ int a=1; if(n==2){ return 1; }else if(n==3){ return 2; }else if(n==4){ return 4; }else{ while(n&gt;4){ n-=3; a*=3; } return a*n; } } 总结dp的思想还是局部最优解的推进，但是可以使用数学知识来简化问题。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"}],"author":"fx-zpy"},{"title":"go实现简单群聊服务器","slug":"goqunliao","date":"2021-10-07T08:44:46.000Z","updated":"2021-10-20T12:36:04.467Z","comments":true,"path":"posts/4b92e806.html","link":"","permalink":"http://fx-zpy.github.io/posts/4b92e806.html","excerpt":"","text":"TCP群聊服务器实现之前实现了TCP服务器，可以和客户端通信，这次进行了扩展，将多个客户端的通信集中到一起，形成群聊系统，服务器的主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) type client struct { c chan string //发送数据的管道 name string //姓名 addr string //地址 } var onlinemap map[string]client //保存在线用户 var message = make(chan string) func manager() { onlinemap = make(map[string]client) for { msg := &lt;-message //如果message通道没有消息就阻塞 for _, cli := range onlinemap { cli.c &lt;- msg //遍历map，给每个成员都发送信息，相当于广播 } } } func writemsgtoclient(cli client, ac net.Conn) { for msg := range cli.c { ac.Write([]byte(msg + \"\\n\")) } } func makemsg(cli client, msg string) (buf string) { buf = \"[\" + cli.addr + \"]\" + cli.name + \":\" + msg return } func dispose(ac net.Conn) { //获取客户端的网络地址 cliaddr := ac.RemoteAddr().String() //创建一个结构体默认用户名和网络地址一样 cli := client{make(chan string), cliaddr, cliaddr} onlinemap[cliaddr] = cli //将结构体添加到map //新开一个协程，给当前客户发送信息 go writemsgtoclient(cli, ac) message &lt;- makemsg(cli, \"login\") cli.c &lt;- makemsg(cli, \"I am here\") isexit := make(chan bool) //新建协程，接受用户发送的数据 go func() { buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) if len == 0 { isexit &lt;- true fmt.Println(\"err=\", err) return } msg := string(buffer[:len-1]) if msg == \"who\" { ac.Write([]byte(\"user list:\\n\")) for _, tmp := range onlinemap { msg = tmp.addr + \":\" + tmp.name + \"\\n\" ac.Write([]byte(msg)) } } else if strings.Count(msg, \"\") &gt;= 8 &amp;&amp; msg[:6] == \"rename\" { name := strings.Split(msg, \"|\")[1] cli.name = name onlinemap[cliaddr] = cli fmt.Println(\"rename successfully\") } else { message &lt;- makemsg(cli, msg) } } }() for { select { case &lt;-isexit: delete(onlinemap, cliaddr) message &lt;- makemsg(cli, \"logout\") } } //开启循环，一直开启协程 } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //开一个协程，转发信息 go manager() //主协程，循环阻塞等待用户连接 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) continue } go dispose(ac) } } 本次服务器开启的端口依旧是本地的4000端口，每个客户端可以修改自己的名称，默认的名称是地址，同时上线和退出都会有login和logout的提示。如果输入的是who那么就会给出当前在线的用户列表。 测试这里我单开一个窗口作为旁观者可以观看到其他人发的信息，俗称摸鱼窥屏怪。其他的我开了三个用户，分别重新命名为zpy,xsg,hs他们进行聊天。 这边hs的视角忘记截图了，不过有前两个人的视角应该就够了，这个群聊做的很简单，界面布局也没有什么设计，包括敏感词汇屏蔽和@功能实现都还没有做，后续随缘更新功能和界面，这次只是为了能够实现聊天的主题功能。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"go学习笔记之tcp服务器","slug":"gotcp","date":"2021-10-05T07:43:46.000Z","updated":"2021-10-20T12:36:56.853Z","comments":true,"path":"posts/db7cd9a0.html","link":"","permalink":"http://fx-zpy.github.io/posts/db7cd9a0.html","excerpt":"","text":"单程TCP服务器这是只接受来自客户端的一次通信就停止的服务器，也是后面并发服务器的基础知识，服务器的构成代码是用go语言编写，如下。 package main import ( \"fmt\" \"net\" ) func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } buffer := make([]byte, 4096) //分配一个4096字节的缓冲区来接收用户的数据 len, err := ac.Read(buffer) //返回数据长度和错误信息 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data=\", string(buffer[:len])) defer ac.Close() } 这里使用net里面的函数listen对本地4000端口进行监听，为啥是4000端口，其实端口号无所谓，4000端口是每次更新博客的时候本地调试的端口，因为经常能看色图博客，所以使用该端口，这里接受信息的缓冲区的大小为4096，也就是4kb，来自4000端口发送的数据大小不能超过该大小，使用的时候不会报错，但是服务器端只会截取规定缓冲区的大小，我实验过使用的大小为4的缓冲区来接受超过10个字节的数据，最后只是截取到前四个字节的数据就结束了。这里使用netcat下的一个可执行程序nc来进行数据的发送。分配好端口号之后就发送数据，同时服务器端接受到数据之后就停止了，因为本身就是一个单程的服务器。 并发服务器并发服务器支持对多个客户端进行数据的传送与接收。 服务器端服务器端的代码在之前单程服务器的基础上进行改进，增加协程来处理与客户端的交互。主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) func Dispose(ac net.Conn) { add := ac.RemoteAddr().String() //处理客户端的端口号 fmt.Println(add, \" connected successfully\") defer ac.Close() buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) //接收客户端数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from client is\", string(buffer[:len])) //打印接收到数据 if string(buffer[:len-1]) == \"exit\" { return } ret := strings.ReplaceAll(string(buffer[:len]), \"sb\", \"**\") //将数据中的不文明词汇和谐，这里只处理了sb这个经常出现的词汇 ac.Write([]byte(ret)) //返回数据 } } func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } go Dispose(ac) } } 这里通过协程对每一个请求的客户端的数据都能进行处理，在实际工作中服务器端接收到客户端的数据之后可以进行很多处理，我这里仅仅进行了对敏感词汇sb的和谐，并把数据重新发回给客户端。上述代码的停止条件是输入exit，这里的处理仅仅适用于nc测试，因为nc测试中我们输入了exit回车之后换行也一并输入了进来，所以上述代码中判断条件为string(buffer[:len-1]) == “exit”，自编客户端程序进行测试的时候由于编写者的不同，数据的处理可能不同。需要根据实际情况进行修改。 测试nc这里我开了两个进程来测试服务器端能否实现并发，结果发现可以。输入exit客户端也能顺利的结束进程。 客户端程序这里也可以自编客户端程序进行测试，主动连接对应的端口号，对其进行数据的交互。这里我写了一个客户端程序进行测试，也是使用go语言进行编写。 package main import ( \"fmt\" \"net\" \"os\" ) func main() { //设置连接的端口号 conn, err := net.Dial(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer conn.Close() //开启协程，接收服务器端的回复 go func() { buffer := make([]byte, 4096) for { len, err := conn.Read(buffer) //读取数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from server is\", string(buffer[:len])) // } }() //给服务器端发送数据 se := make([]byte, 4096) for { len, err := os.Stdin.Read(se) //从键盘读取内容 if err != nil { fmt.Println(\"err=\", err) return } conn.Write(se[:len]) //将输入的信息发送给服务器 } } 测试截图如下 注意这里输入exit不能退出，因为客户端输入的时候输入回车，字符串后面会跟着两个字符，回车\\r，换行\\n，所以服务器端需要进行修改才能退出客户端程序，即将服务器端的判断条件改为string(buffer[:len-1]) == “exit”。但是这样感觉不方便，可以在测试的客户端输入条件判断一下，为exit就退出。当然这些都是小细节。 总结单程和并发区别在于是否使用了协程，本次测试也用到了脑残nc和客户端程序。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"合唱队形&&过河卒","slug":"dp1","date":"2021-10-04T08:28:18.000Z","updated":"2021-10-20T13:01:39.083Z","comments":true,"path":"posts/9c48d863.html","link":"","permalink":"http://fx-zpy.github.io/posts/9c48d863.html","excerpt":"","text":"合唱队形题目描述N位同学站成一排，音乐老师要请其中的(N?K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1,2,…,K，他们的身高分别为T1,T2,…,TK。身高满足T1&lt;…Ti+1&gt;…&gt;TK(1≤i≤K)。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。输入有两行，第一行是一个整数N(2≤N≤100)，表示同学的总数。第二行有N个整数，用空格分隔，第i个整数Ti(130≤Ti≤230)是第i位同学的身高(厘米)。输出最少需要同学出列的个数。 思路第一次错误尝试第一次我的思路是每次标定一个人，从他开始依次向左和右进行筛选，如果有后一个比前一个高的情况出现，就判定前一个得出队列，当然我还没有意识到问题的严重性，连调试都没做就去提交了，结果可想而知，10个测试点就过了一个，以下是第一次的代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int min=150,flag,a; int t[100] = { 0 }; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); for (int j = 0; j &lt; 100; j++) { flag = 0; a = t[j]; for (int i = j; i &lt; 99; i++) { if (a &lt; t[i + 1])flag++; else a = t[i + 1]; } a = t[j]; for (int i = j; i &gt; 0; i--) { if (a &lt; t[i - 1])flag++; else a = t[i - 1]; } if (flag &lt; min)min = flag; } printf(\"%d\\n\", min); } 错误以后我自己进行了分析，发现，如果在我选定的那一个人的右边第一位是他右边最低的，而从右边第二位开始依次递减，那么我的算法就把从第二位开始的人全部踢出去了这显然不符合最少的规则，正确的是只需要把右边第一位踢出去就可以了。 第二次尝试经过分析以后，我开始转换思路，依旧选定一个人做参照，将合唱队分成两个部分，然后分别从最左边和最右边向中间求最多人的增序列，这样踢出去的人就最少，两个数组分别存储左右的最大增序列的人数，但是注意，被当做参照物的那个人算了两次，所以要减去1。代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int uflag,dflag; int t[100] = { 0 }; int u[100], d[100]; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); u[0] = 1; d[n - 1] = 1; for (int i = 1; i &lt; n; i++) { uflag = 1; for (int j = 0; j &lt; i; j++) { if (t[i] &gt; t[j])uflag = uflag &gt; u[j] + 1 ? uflag : u[j] + 1; } u[i] = uflag; } for (int i = n - 2; i &gt;= 0; i--) { dflag = 1; for (int j = n - 1; j &gt; i; j--) { if (t[i] &gt; t[j])dflag = dflag &gt; d[j] + 1 ? dflag : d[j] + 1; } d[i] = dflag; } int max = 0; for (int i = 0; i &lt; n; i++) { if (u[i] + d[i] - 1 &gt; max) max = u[i] + d[i] - 1; } printf(\"%d\\n\",n-max); } 成功通过了OJ。 过河卒题目描述棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点(0,0)、B点(n,m)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。输入一行四个正整数，分别表示B点坐标和马的坐标。坐标不超过（20,20）。输出一个整数，表示所有的路径条数。 思路思路就是没有思路题目给我的第一印象就是好难啊，我把题目给的一个示例在草稿纸上人工走了一遍，但是没有思路，如果没有这匹该死的马，那将简单多了，就像之前的小蜜蜂和爬楼梯一样，但是可惜没有，一个马最多限制了九个点无法通过，有可能马的位置离边境较近，9个点中有部分不在（0,0）和（n,m）为顶点组成的矩形里面，我的初始想法是先求出所有的路径，然后把路径中包含马的控制点的路径排除，这个想法我没去实现，因为我在大脑里面过了一下，预感时空限制可能通不过OJ，于是打开了谷歌，搜索过河卒（bushi。看了别人的思路之后感觉豁然开朗，路径条数的dp还是我之前说的那样，每到每一个点的个数是上面点和左边点的个数之和，这里我用了一个二维数组，初始化都为0，将马的控制点设置为-1（之后再调整为0），每个数组元素的值就是到该点的路径条数之和，再用dp到(n,m)。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int x, y, m, n; int long long path[25][25] = { 0 }; int mx[8] = { -2,-2,-1,-1,1,1,2,2 }; int my[8] = { 1,-1,2,-2,2,-2,1,-1 }; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;x, &amp;y); getchar(); n += 1; m += 1; x += 1; y += 1; for (int i = 0; i &lt; 8; i++) { if (x + mx[i] &gt;= 1 &amp;&amp; x + mx[i] &lt;= n &amp;&amp; y + my[i] &gt;= 1 &amp;&amp; y + my[i] &lt;= m)path[x + mx[i]][y + my[i]] = -1; } path[x][y] = -1; path[1][0] = 1; for (int i = 1; i&lt;= n; i++) { for (int j = 1; j &lt;=m; j++) { if (path[i][j] == -1)path[i][j] = 0; else path[i][j] = path[i][j - 1] + path[i - 1][j]; } } printf(\"%lld\\n\", path[n][m]); return 0; } 这么简单的题目我都能卡住，我太菜了o(╥﹏╥)o，CSP危。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"},{"title":"逆向简单题之dotnetcrack","slug":"pwn-dotnetcrack","date":"2021-10-03T02:36:08.000Z","updated":"2021-10-20T12:55:29.436Z","comments":true,"path":"posts/a651b15e.html","link":"","permalink":"http://fx-zpy.github.io/posts/a651b15e.html","excerpt":"","text":"题目背景这道题是我的一个同学转了安全以后发给我让我帮忙做一下，但是其实本来我也没有接触多少逆向的知识，但是还是打算尝试一下，题目是dotnetcrack，打开可执行程序以后，弹出一个弹窗如下 尝试输入一串字符串，发现报错。 学习了一下这方面的知识以后，也是使用了一款反编译工具ILSpy将程序进行反编译，找到判断的关键代码， 如图可以发现其判断的语句是”2yyUjXprc1+2TwAbbVU6eQ==” == Encode(textBox1.Text)，显然，正确的字符串进行某种规则加密后的密文为2yyUjXprc1+2TwAbbVU6eQ==。 解法一：投机取巧已知判断条件之后，可以修改判断条件为!=，因为随机输入一串字符串，相等的概率极低，那么相反，不相等的概率极高，修改之后，随便输入只要不是正确的明文就可以弹出恭喜的弹窗，实验了一下，因为ILSpy不能直接修改代码，所以讲代码保存出来进行修改， 保存之后重新编译该文件，这样随便输入就可以弹出正确的弹窗了。 解法二：再次投机取巧由于解法一虽然可以弹出正确的弹窗，但是正确的明文却还是不知道，所以这次还是投机取巧的办法，但是能够获取明文，这里针对加密函数编写了一段解密函数。 public string Decode(string data) { string result; byte[] byte1; try { byte1 = Convert.FromBase64String(\"2yyUjXprc1+2TwAbbVU6eQ==\"); byte[] bytes = Encoding.ASCII.GetBytes(\"gctf{got\"); byte[] bytes2 = Encoding.ASCII.GetBytes(\"2niceday}\"); DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateDecryptor(bytes, bytes2), CryptoStreamMode.Write); cryptoStream.Write(byte1, 0, byte1.Length); cryptoStream.FlushFinalBlock(); System.Text.Encoding encoding = System.Text.Encoding.UTF8; result = encoding.GetString(memoryStream.ToArray()); } catch { result = \"\"; } return result; } 利用该解密函数正确的密文进行解密得到正确的明文，这次不修改判断逻辑，修改错误的输出为解密正确的密文得到的明文。 private void button1_Click(object sender, EventArgs e) { if (\"2yyUjXprc1+2TwAbbVU6eQ==\" == Encode(textBox1.Text)) { MessageBox.Show(\"Congratulation~!!\"); } else { MessageBox.Show(Decode(textBox1.Text)); } } textBox1.Text就是我们输入的内容，那么我们输入密文，弹出的就是正确的明文了 这样就可以得到明文内容了，是H0lyTru3EasY，这里再把明文输入就可以得到正确的提示了。 解法三：直接解密因为上个学期也学过密码学原理这门课，虽然我学的不咋地，但是还是尝试读懂了加密函数，发现这里采用了DES的CBC加密模式，并且使用了Base64进行编码，那么可以直接利用网上的解密工具，密钥从代码中可以得知是gctf{got，偏移值是2niceday}，直接进行解密也能获得明文。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}],"author":"fx-zpy"},{"title":"第一篇博客&&动态规划","slug":"dp0","date":"2021-10-02T03:43:08.000Z","updated":"2021-11-08T04:18:48.305Z","comments":true,"path":"posts/62cb98ee.html","link":"","permalink":"http://fx-zpy.github.io/posts/62cb98ee.html","excerpt":"","text":"数字三角形题目描述观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。第一个行一个正整数r,表示行的数目。后面每行为这个数字金字塔特定行包含的整数。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 思路动态规划有两种路线，这道题我选择了从底向上，用一个数组来存储每一个点的局部最大和，从倒数第二层开始，一直到顶层，最后得到的数组的第一位数就是最大值，代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int r; int num[1001] = { 0 }; scanf(\"%d\", &amp;r); getchar(); int array[1001][1001] = { 0 }; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; i || j == i; j++) { scanf(\"%d\", &amp;array[i][j]); } getchar(); } for (int j = 0; j &lt; r - 1; j++) { if (array[r-1][j] &gt; array[r-1][j + 1]) num[j] = array[r-2][j] + array[r-1][j]; else num[j] = array[r-2][j] + array[r-1][j + 1]; } for (int i = r - 3; i &gt; 0||i==0; i--) { for (int j = 0; j &lt; i || j == i; j++) { if (num[j] &gt; num[j + 1]) num[j] = num[j] + array[i][j]; else num[j] = num[j + 1] + array[i][j]; } } printf(\"%d\", num[0]); return 0; } 最后可以通过OJ平台，但是在vs调试的时候发现数组栈溢出了。 母牛的故事题目描述有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 思路通过列举前几年的关系，发现规律，前4年的数量和年份相同，第五年的时候，第二年的两头牛是成年母牛可以生殖了，所以应该是上一年的数量加上上四年的数量，因为题目给的年份不多，所以用一个55位的数组存储每一年的数量，再根据输入n的值，直接输出数组[n]。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int n; scanf(\"%d\", &amp;n); getchar(); int num[55] = { 0 }; for (int i = 1; i &lt; 55; i++) { if (i &gt; 0 &amp;&amp; i &lt; 5)num[i] = i; else num[i] = num[i-1] + num[i - 3]; } while (n != 0) { printf(\"%d\\n\", num[n]); scanf(\"%d\", &amp;n); getchar(); } return 0; } 一只小蜜蜂题目描述有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。对于每一个测试样例，输出蜜蜂从蜂房a到蜂房b的可能路线数。 思路分析可知，a比b小，从a到b直接不好分析，从b开始，能直接到b的有b-1和b-2那么路线数就是两者之和，再分析b-1和b-2，发现规律一致，也是题目便利，数据都不大，可以用数组来表示可能路线数，这里的数组下标是两者的距离。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a, b; long long int k[50] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 50; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d%d\", &amp;a, &amp;b); getchar(); printf(\"%lld\\n\", k[b - a]); } return 0; } 这里有个坑，初始我定义k的时候类型是int，但是OJ报错，查了一下资料才发现数据越界，于是改成lli就行了。 爬楼梯题目描述有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数，对于每个测试实例，请输出不同走法的数量。 思路这道题目读完以后不难发现，和小蜜蜂基本一致，只不过a固定是1罢了，数据范围还小了，直接上代码。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a; long long int k[41] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 41; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d\", &amp;a); getchar(); printf(\"%lld\\n\", k[a-1]); } return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://fx-zpy.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据库","slug":"数据库","permalink":"http://fx-zpy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fx-zpy.github.io/tags/C/"},{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"database","slug":"database","permalink":"http://fx-zpy.github.io/tags/database/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"},{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"},{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}]}