{"meta":{"title":"无言","subtitle":"无言","description":"本科 | 前后端 | 网络安全","author":"fx-zpy","url":"http://fx-zpy.github.io","root":"/"},"pages":[{"title":"404","date":"2021-10-01T08:41:10.000Z","updated":"2021-10-02T08:05:34.615Z","comments":true,"path":"404.html","permalink":"http://fx-zpy.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-10-18T03:23:48.133Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://fx-zpy.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-10-26T02:58:50.309Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://fx-zpy.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:09.871Z","comments":true,"path":"about/index.html","permalink":"http://fx-zpy.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"http://fx-zpy.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:29.685Z","comments":true,"path":"archives/index.html","permalink":"http://fx-zpy.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:02:47.705Z","comments":true,"path":"categories/index.html","permalink":"http://fx-zpy.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2021-10-02T02:11:28.000Z","updated":"2021-10-02T08:03:07.775Z","comments":true,"path":"census/index.html","permalink":"http://fx-zpy.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-02T08:38:37.552Z","comments":true,"path":"contact/index.html","permalink":"http://fx-zpy.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 无言友链信息 博客名称: 无言 博客网址: http://fx-zpy.github.io 博客头像: https://www.wahaotu.com/uploads/allimg/202011/1604238640214543.jpg 博客介绍: a little vegetable chicken"},{"title":"友链","date":"2021-10-02T08:42:10.000Z","updated":"2021-10-02T08:03:53.032Z","comments":true,"path":"friends/index.html","permalink":"http://fx-zpy.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"http://fx-zpy.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-01T08:40:27.000Z","updated":"2021-10-02T08:05:01.978Z","comments":true,"path":"tags/index.html","permalink":"http://fx-zpy.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-10-01T14:43:14.557Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"http://fx-zpy.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"开心一刻","date":"2021-10-20T05:10:10.000Z","updated":"2021-10-20T05:10:01.767Z","comments":true,"path":"List/movies/index.html","permalink":"http://fx-zpy.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"http://fx-zpy.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"回忆青春","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-08T04:23:24.485Z","comments":true,"path":"List/music/index.html","permalink":"http://fx-zpy.github.io/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-10-01T14:43:14.560Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-10-01T14:43:14.566Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-10-01T14:43:14.568Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-10-01T14:43:14.569Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-10-01T14:43:14.570Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-10-01T14:43:14.572Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-10-01T14:43:14.573Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-10-01T14:43:14.576Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-10-01T14:43:14.578Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-10-01T14:43:14.577Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-10-01T14:43:14.580Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://fx-zpy.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库知识体系","slug":"databaseknowledge","date":"2021-11-11T10:29:08.000Z","updated":"2021-11-12T13:36:49.127Z","comments":true,"path":"posts/d43b3954.html","link":"","permalink":"http://fx-zpy.github.io/posts/d43b3954.html","excerpt":"","text":"第一章 绪论 文件系统和数据库的区别 数据结构性 文件系统把数据组织成相互独立的数据文件，实现了记录内的结构性，但整体无结构 l数据库系统实现整体数据的结构化，也是数据库系统与文件系统的本质区别 数据独立性 文件系统中的文件是为某一特定应用服务的，当要修改数据的逻辑结构时，必须修改应用程序，修改文件结构的定义，数据和程序之间缺乏独立性 数据库系统中，通过DBMS的两级映象实现了数据的物理独立性和逻辑独立性，把数据的定义从程序中分离出去，减少了应用程序的维护和修改 数据共享 数据库系统的共享度高。系统现有用户和程序可以共享数据库中的数据；当系统扩充时还可以开发出新的用户和程序来共享原有数据库资源；多用户或或程序可以在同一时刻共享同一数据 文件系统实现以文件为单位的数据共享 数据冗余 在文件系统中，数据冗余度大，浪费存储空间，容易造成数据的不一致 数据库系统中，数据是面向整个系统，数据可以被多个用户、多个应用共享使用，减少了数据冗余 数据库管理系统（DBMS）是位于用户与操作系统之间的一层数据管理软件，是一个大型的复杂的软件系统，用于科学地组织和存储数据、高效地获取和维护数据 ACID：数据库事务正确执行的四个基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 数据库管理系统的功能 数据定义功能 提供数据定义语言（DDL） 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据库操作功能 提供数据操纵语言（DML） 实现对数据库的基本操作 （查询、插入、删除和修改） 数据库的事务管理和运行管理 数据库在建立、运行和维护时由数据库管理系统统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库的建立和维护功能 数据库初始数据的装载和转换 数据库转储、恢复功能 数据库的重组织 性能监视、分析等 其他功能 数据库管理系统与网络中其它软件系统的通信 数据库管理系统系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统（DBS）组成 数据库 DBMS 应用程序 数据库管理员 数据库类型 文件型数据库—文件型数据库可以认为是最简单的一种数据库模型，其实现非常简单，就是读写一个简单的文件，分隔符多样，文件类型可以是CSV、TSV或者是JSON文件。数据直接以人类可读的形式呈现，程序也比较容易解析。文件型数据库其实现非常简单，同样地这也限制了它的使用。例如在并发和并行的场景下，文件型数据库就表现的不是那么友好，且读取性能不是那么优秀，单点查询和范围查找的需要从头遍历整个文件 层次数据库—层次数据库模型诞生于1960年代，是文件型数据的下一个形态。层次数据库模型类似于一个树状结构，每条记录有且仅有一个父节点，类似于下图。层次数据库是人们第一次尝试去思考和处理复杂数据，在一定程度上提升了文件型数据库的一些特定数据读取方式的性能，但是层次数据库是基于树状的模型，访问层次数据库类似于遍历链表，很难实现对复杂数据的读取 网状数据库—网状数据库也诞生于1960年代。数据系统语言会议（（Conference on Data Systems Languages,CODASYL）的委员会标准化了网状数据库模型，因此网状数据库模型也被称为 CODASYL 模型。网状数据库进一步发展了层次数据库模型，解决了层次数据库有且仅有一个父节点的问题。网状数据库模型的子节点可以拥有多个父节点，同时这也带来了更高的复杂性。和层次数据库模型一样，网状数据库模型的查询和更新都需要遍历链表，给开发带了无尽的难度，这使得网状数据库模型逐渐没落。毕竟能使用网状数据库模型的地方 关系型数据库—关系型数据库模型诞生于1960年代，是现存的数据库模型中活得最久、生命力最旺盛、使用的最为广泛的数据模型。关系型数据库模型在刚提出来时，并不受到待见，但是在二十世纪八十年代成为了绝大多数人的首选数据库。关系型数据库模型基于关系代数，它认为：数据可以被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。换句话说，一个关系（表）只是一个元 组（行）的集合。关系型数据库模型解决了层次数据库模型无法表达多对多关系的能力；在关系型数据库中，读取数据时不再需要像访问链表一样去访问数据，开发者可以随意读取表中的任意行和列；并且关系型数据库引入了外键的概念，使得表和表之间可以轻易的关联起来•适用于关系型数据库的查询语言是SQL。SQL作为一个图灵完备的语言，已经不仅仅局限于关系型数据库，而是成为数据库领域中当之无愧的王者。SQL的核心在于查询优化器，由查询优化器自动决定SQL的哪些部分以哪个顺序执行，以及使用什么索引。总的来说，关系型数据库模型以其强大的灵活性和适应力成为了开发者的首选数据库模型 数据模型 概念数据模型：是对现实世界的抽象 逻辑数据模型 物理数据模型 三级模式结构 关系数据库中的模式一定是关系的，在该层可见的实体是关系的表和关系的操作符 外模式也是关系的，它的内容是来自模式 内模式不是关系的，它是数据的物理存储方式 第二章 关系数据库关系代数 关系代数 关系模型源于数学，关系是由元组构成的集合，可以通过关系的运算来表达查询要求 关系代数是关系数据库的基础 关系代数是关系操作语言的一种传统的表示方式，它是一种抽象的查询语言 关系代数的运算可分为两大类 传统的集合运算：广义笛卡尔积运算、并、交和差运算 专门的关系运算：选择、投影、连接和除运算 关系代数运算符 专门的关系运算 选择 在关系R中选择满足给定条件的诸元组 σF(R) = {t|t∈R∧F(t)=’true’} F：选择条件，是一个逻辑表达式，取值为“true”或“false”基本形式为：F(t) = X1 θ Y1θ表示比较运算符，它可以是＞，≥，＜，≤，＝ 或 ≠ 选择运算是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算 投影 从R中选择出若干属性列组成新的关系 ∏A(R) = { t[A] | t ∈R } A：R中的属性列投影操作主要是从列的角度进行运算 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） 连接 连接也称为θ连接,连接运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组 A和B：分别为R和S上度数相等且可比的属性组，θ：比较运算符 连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 等值连接：θ为“＝”的连接运算 自然连接：一种特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组在结果中把重复的属性列去掉，假设R和S具有相同的属性组B 等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接 除运算 经常用于求解“查询…全部的/所以的…”问题前提条件：给定关系R(A1,A2,…,An)为n度（目）关系，关系S(B1，B2,…,Bm)为m度关系。如果可以进行关系R与关系S 的除运算，当且仅当：属性集(B1，B2,…,Bm)是属性集(A1,A2,…,An)的真子集，即m&lt;n。定义：关系S和关系R的除运算也是一个关系，记作：R ÷ S, 分两部分来定义。 先定义R ÷ S结果的属性应有哪些？设属性集{C1,C2,…,Ck} = {A1,A2,…,An} – {B1,B2,…,Bm} , 则有 k=n-m, R ÷ S结果关系是一个k(n-m)度关系，由{C1,C2,…,Ck} 属性组成。 再定义R ÷ S的元组怎样形成？再设关系R(&lt;a1,a2,…,an&gt;)和关系S(&lt; b1,b2,…,bm &gt;),那么R÷S结果关系为元组&lt; c1,c2,…,ck &gt;的集合，元组 &lt; c1,c2,…,ck &gt;满足下述条件：R÷S中&lt; c1,c2,…,ck &gt;与S中的每一个元组&lt; b1,b2,…,bm &gt;组合形成的一个元组都是R中的某一个元组&lt;a1,a2,…,an&gt;。（其中 a1,a2,…,an， b1,b2,…,bm ， c1,c2,…,ck 分别为 A1,…,An,B1,…,Bm,C1,…,Ck的值） ​ R ÷ S = {t | t∈∏R-S (R) ∧∀u∈S(tu∈R)} 符号表示 设关系模式是R(A1,A2,….,An) R: 是关系模式R(A1, A2, …,An)的一个关系 t∈ R : 表示t是R的一个元组 t[Ai] : 表示元组t中相应于Ai的一个分量(元组 t对应字段或属性Ai的值) 若 A = {Ai1, Ai2, …,Aik}, 其中Ai1，Ai2, …,Aik 是A1，A2,…,An中的一部分，则A称为属性列或属性组 t[A] = (t[Ai1], t[Ai2] …,t[Aik]) 表示元组t在属性列A上诸分量的集合 Ā 则表示{A1, A2, …,An}中去掉{Ai1, Ai2, …,Aik}后剩余的属性组 R 为n 目关系，S为m目关系。 tr ∈R, ts ∈ S, 称为元组连接，且是一个n+m列的元组，前n个分量是R中的一个n元组，后m个分量是S中的一个m分量 给定一个关系R(X,Y),X和Y为属性组。当t[X] = x 时，x在R中的象集(Image Set)为：Yx = {t[Y]|t∈R, t[X] = x}它表示R中属性组X上值为x的诸元组在Y上分量的集合 关系模型 域：是一组具有相同数据类型值的集合，域指的是属性的取值范围,也就是不同元组对同一属性的取值所限定的范围例如，整数、正整数、实数、大于等于0且小于等于100的正整数、{0,1,2,3,4}等都可以是域 基数：一个域允许的不同取值个数称为这个域的基数 属性：每列取一个名字 键 超键：超键是表中字段的任何组合，可以唯一地标识该表中的每个记录 候选键：候选键是超键的子集。候选键是唯一标识表中每个记录的单个字段或字段的最小组合。字段的最小组合将候选键与超键区分开。每个表必须至少具有一个候选键，但同时可以具有多个候选键 候选键必须包含唯一值，不能包含空值，包含最少数量的字段来确保唯一性，必须唯一标识表中的每个记录 主键：是最适合用作表的主要参考键的候选键。顾名思义，它是表引用的主键，并在整个数据库中用于帮助与其他表建立关系。与任何候选键一样，主键必须包含唯一值，绝不能为null，并且唯一标识表中的每个记录 每个表都必须有主键每个记录必须为其主键有一个值从候选键中选择主键时，选择一个简单键 外键：通常是一个表中的主键，它在另一个表中作为字段出现，其中第一个表与第二个表有关系。换句话说，如果我们有一个表A，该表的主键X链接到表B，其中X是B中的一个字段，那么X将是B中的外键。 替代键：一个表可能有一个或多个主键选择。如前所述，它们被统称为候选键。选择一个作为主键。未选择的键称为替代键 唯一键：唯一键是表的一个或多个字段/列的集合，它们唯一地标识数据库表中的记录。就像主键一样，但是它只能接受一个空值，并且不能有重复值 主键与唯一键的区别：主键不能接受空值，而唯一键可以接受一个空值主键是聚簇索引，并且数据库表中的数据按照聚簇索引的顺序进行物理组织。唯一键是唯一的非聚集索引一个表中只能有一个主键。而一个表中有多个唯一键 关系的限定和扩充 限定：无限关系在数据库系统中是无意义的，限定关系数据模型中的关系必须是有限集合 扩充：通过为关系的每个列附加一个属性名的方法取消关系属性的有序性 数学上 （计算机，信息）≠ (信息，计算机)数据库上 （计算机，信息）= (信息，计算机) 关系数据库：所有关系的集合 型：关系数据库的型称为关系数据库模式，是对关系数据库的描述 值：关系数据库的值是这些关系模式在某些时刻对应的关系的集合，通常称作关系数据库 关系的完整性约束 实体完整性：主码不能取空值 参照完整性：一个关系的外键必须是另一个关系的主键，也可以是空 用户定义的完整性：指对关系中每个属性的取值作一个限制(或称为约束)的具体定义 第三章 SQLDDL语言 SQL（结构化查询语言）是一种非过程化的语言，使用者只需要说明“做什么”而不需要说明“怎么做”，是关系数据库的标准语言，通用功能强 SQL集定义、操作、查询和控制为一体 SQL表的数据类型 SQL表语句的基本语法 创建表 CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] … [,&lt;表级完整性约束条件&gt; ] ); 例如：创建一个课程的表 CREATE TABLE Course ( Cno CHAR(4) PRIMARY KEY, //主键 Cname CHAR(40), Cpno CHAR(4), Ccredit SMALLINT， FOREIGN KEY (Cpno) REFERENCES Course(Cno) //外键，Course(Cno)为被参照表（被参照列） ); 修改表 ALTER TABLE &lt;表名&gt; [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ] [ ADD &lt;表级完整性约束&gt;] [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ] [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ] [ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] - ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件 - DROP COLUMN子句用于删除表中的列如果指定了CASCADE短语，则自动删除引用了该列的其他对象如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列 - DROP CONSTRAINT子句用于删除指定的完整性约束条件 - ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型 - 删除列: ALTER TABLE 表名 DROP COLUMN 列名 增加列: ALTER TABLE 表名 ADD COLUMN 列名 属性 【约束】 修改列类型: ALTER TABLE 表名 CHANGE COLUMN 列名 新列名 【新属性】 重命名列: ALTER TABLE 表名字 CHANGE COLUMN 列名 新列名 重命名表: ALTER TABLE 表名 RENAME TO 表新名 删除表中主键: ALTER TABLE 表名 DROP PRIMARY KEY 添加主键: ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY (添加列) 添加索引: ALTER TABLE 表名 ADD INDEX 索引名 (列名) 修改列的属性: ALTER TABLE 表名 MODIFY COLUMN 列名 新属性 删除表 DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］ RESTRICT：删除表是有限制的 欲删除的基本表不能被其他表的约束所引用； 如果存在依赖该表的对象，则此表不能被删除CASCADE：删除该表没有限制 在删除基本表的同时，相关的依赖对象（表定义、数据、索引、视图、触发器等）一起删除 SQL索引 创建索引 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…) &lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔 &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 删除索引 DROP INDEX &lt;索引名&gt; SQL视图 定义：视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化 优点 简化用户操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当的利用视图可以更清晰地表达查询 创建视图 CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…) AS &lt;子查询&gt; [WITH CHECK OPTION]; 子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现 WITH CHECK OPTION：对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式） 删除视图 DROP VIEW &lt;视图名&gt;[CASCADE] 该语句从数据字典中删除指定的视图定义如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 更新视图 插入 INSERT INTO IS_Student VALUES(‘201215129’,’赵新’,20) 修改 UPDATE IS_Student SET Sname= ‘刘辰’ WHERE Sno= ‘201215122’ 删除 DELETE FROM IS_Student WHERE Sno= ' 201215129 ' 单表和多表查询 SQL查询 SELECT [&lt;SELECT选项&gt;] &lt;字段列表[字段别名] [表达式] [常量] [(SELECT子句)] &gt; FROM 子句 [WHERE子句] [GROUP BY子句 ] [HAVING 子句] [ORDER BY 子句] [LIMIT 子句]; SELECT选项：ALL(缺省)和DISTINCT SELECT子句：指定要显示的属性列 FROM子句：指定查询对象（基本表或视图） WHERE子句：指定查询条件 GROUP BY子句：对查询结果按指定列的值分组 该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。 HAVING短语：只有满足指定条件的组才予以输出 ORDER BY子句：对查询结果表按指定列值的升序或降序排序 LIMIT子句：用于限制查询结果返回的数量 SQL TOP子句 TOP TOP 子句用于规定要返回的记录的数目num。对于拥有数千条记录的大型表来说 TOP 子句是非常有用的 例如：SELECT TOP 50 PERCENT * FROM Persons 并非所有的数据库都支持TOP子句 SQL alias（别名） 为什么要用别名 数据库中往往过长的表名或列名会对我们数据统计,显示（中文）造成困扰 书写比较方便 别名怎么定义和使用 Select 字段 AS 别名 Select 字段 别名 Select 别名=字段 From student as s From student s From s=student 这一部分的SQL语句平时用多了自然就熟练了，基础知识真没啥好说的","categories":[{"name":"数据库","slug":"数据库","permalink":"http://fx-zpy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"database","slug":"database","permalink":"http://fx-zpy.github.io/tags/database/"},{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（三）","slug":"winnet2","date":"2021-11-11T08:00:08.000Z","updated":"2021-11-11T10:29:24.173Z","comments":true,"path":"posts/ed71a2a6.html","link":"","permalink":"http://fx-zpy.github.io/posts/ed71a2a6.html","excerpt":"","text":"四、网络层数据平面","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（二）","slug":"winnet1","date":"2021-11-10T04:43:08.000Z","updated":"2021-11-11T10:29:09.080Z","comments":true,"path":"posts/a06f01f4.html","link":"","permalink":"http://fx-zpy.github.io/posts/a06f01f4.html","excerpt":"","text":"二、应用层知识点 网络应用的架构有三种：C/S模型（客户端/服务器）、对等网（Peer-to-Peer，P2P）、混合体系（C/S+P2P) C/S:服务器总是打开拥有一个固定的地址并且是一个缩放的数据中心，客户端可以和服务器通信，但不能与客户端通信，且通信可能是间歇性的，客户端拥有动态的IP地址 P2P：客户端之间是对等的，可以通信，提供服务也享受服务，结点之间的连接是间歇性的地址也是变化的 网络应用进程使用套接字来唯一确定 套接字包含主机地址和端口号 主机地址：标识该网络应用进程运行在网上哪一台主机上，通常使用32位的ip地址来进行标识。 端口地址：在该主机上标识该网络应用进程，通常使用16位的端口号来进行标识 运输层传输协议主要有两个：TCP和UDP TCP 面向连接：在客户端和服务器端进程之间需要进行连接 可靠传输：在发送和接受进程之间 流量控制：发送数据的速度不会超过接受的速度 拥塞控制：当网络超负荷时，减缓发送速度 目前缺陷：不提供最小带宽承诺和实时性传输 UDP 不可靠的数据传输 不需要建立连接 没有流量控制和拥塞控制 不提供实时传输和最小带宽承诺 应用层协议 HTTP 无状态的：服务器不保留任何访问过的请求信息 保留过去的请求信息会造成隐患，如果浏览器或者服务器崩溃那么各自的状态视图就会发生分歧，需要重新核对 HTTP采用TCP来作为运输协议步骤如下 客户端启动TCP连接（创建套接字）到服务器，端口80 服务器接受来自客户端的TCP连接 http报文（应用层协议报文）在浏览器和web服务器之间进行交换 关闭TCP连接 HTTP传输模式 1.0—非持久连接：每个TCP连接仅仅传输一个请求报文和响应报文，即每个TCP连接在浏览器发送一个对象之后就会关闭，不会持续连接 1.1—持久连接：服务器发送响应报文以后，TCP连接不会立即断开，继续保持这连接状态，知道长时间没有对象的运输才进行断开，减少了对服务器的套接字的占用，提高了服务器的负载能力 非流水线方式：一个对象传输完成才能传输下一个对象 流水线方式：一次性的发送所有的请求，慢慢接受 一般的HTTP请求报文格式 典型的HTTP请求报文格式 HTTP请求行支持的方法 GET（1.0/1.1）：向服务器请求指定的URL的对象 POST（1.0/1.1）：用于向服务器提交表单数据也可以请求一个web页面 可以不使用POST方法而使用GET方法发送表单数据来获取新的WEB页面，例如搜索引擎 HEAD（1.0/1.1）：请求服务器返回一个响应报文，但是报文中不包含请求对象，该方法常常用来进行故障追踪 PUT（1.1）：上传的文件放在实体主体字段中，目标路径由URL字段标明 DELETE（1.1）：删除URL字段中指定的文件 HTTP响应报文的一般格式 HTTP响应报文具体例子 常见的HTTP响应状态码和短语 200—OK：请求成功，被请求的对象在报文中 301—Moved Permanently：被请求的对象移动过，新的位置在报文中有说明 400—Bad Request：服务器不懂请求报文 404—Not Found：服务器上找不到请求对象，色情网站经常这样 505—HTTP Version Not Supported:服务器不支持请求报文使用的HTTP协议版本 Cookie web站点为什么使用cookie 限制用户的访问 把内容和用户的身份关联起来 cookie技术的组成部分 HTTP请求和响应报文里面各有一个cookie的首部行 用户的端系统上保留了一个cookie文件，由浏览器负责管理 web站点有一个后端数据库 cookie工作流程 cookie和私密性 cookie允许网站获取用户的信息包括用户在一些站点用于登录的个人信息 搜索引擎可以通过cookie和重定向技术获取更多的信息 其他广告公司也能从中获取用户的信息 SMTP 全称简单邮件传输协议，使用TCP可靠的传送邮件报文，端口为25 直接传输 传输的三个阶段 握手（打招呼） 报文传输 结束 命令：ASCll文本 响应：状态码和状态短语 邮件报文必须使用7-bit ASCll表示，非ASCll也可以使用MIME扩展来实现转换 非ASCll的MIME扩展 MIME和SMTP的关系 邮件访问协议：邮件已经传送到目的服务器上了，接收方通过邮件访问协议来读取邮件 POP3（第三版的邮局协议） 特许阶段：用户代理发送用户名和口令（明文）来鉴别用户 事务处理阶段：用户代理取回报文，并且可以对报文做删除标记或者删除这些标记 更新阶段：客户发出quit命令之后，删除第二步被标记为删除的报文，然后结束POP3会话 POP3会话没有状态，用户也无法在邮件服务器上对自己的邮件进行重组织，只能将邮件先下载到本地再进行重组织 IMAP（因特网邮件访问协议） 将所有的邮件都保存在服务器上 允许用户在服务器上组织自己的邮件目录 维护了IMAP会话的用户信息：目录名和报文ID与目录名之间的映射关系 HTTP：基于web的电子邮件在浏览器和邮件服务器之间传输使用的是HTTP协议，但是邮件服务器之间的传输依旧是SMTP DNS：用于IP地址和域名之间的转换 DNS是一个分布式的数据库，由很多台DNS服务器按照层次结构组织起来 DNS运行在端到端系统上，且使用的是UDP协议（53号端口）进行报文传输，因此DNS是应用层协议 以C/S模式工作 DNS解析过程例子 DNS实现 三、运输层知识点总结 运输层为不同主机上运行的应用进程之间提供逻辑通信 运输层协议发送方将应用数据划分成报文段，交给网络层，接受方把报文段重组成应用数据，交付给应用层 网络层是不同主机的通信，而运输层是应用进程之间的通信 多路复用和多路分解 使用UDP套接字的时候，数据报中需要指定目的IP地址和目的端口，使用TCP套接字的时候，则还需要指定源IP地址和源端口号 UDP 发送方 从应用进程得到数据 附加上多路分解和复用所需的源和目的端口号以及差错检测信息，形成报文段 递交给网络层，尽力的传送给接收方的主机（我发了，收不收的到得看人品） 接收方 从网络层接受报文段（数据报） 根据目的端口号，将数据交付给相应的应用进程 UDP通信不需要握手，是无连接的，而且无需维护连接状态，段首部开销比TCP小，TCP20字节，UDP只需要8个字节，而且无拥塞控制，可以按需随时发送 UDP的校验和=报文段的所有16比特字的和再进行反码转换，接收方将所有16比特字和校验和相加，结果如果不是全1，说明有错误，是全1，也有可能出错。 Rdt1.0:经完全可靠信道的可靠数据传输（底层信号非常可靠，无比特差错，无分组丢失） Rdt2.0:经具有比特差错信道的可靠数据传输（肯定确认、否定确认），这种基于重传机制的可靠数据传输协议被称为自动重传请求（ARQ）协议，在ARQ协议中有三种协议功能来处理比特差错的情况：差错检测 、接收方反馈 、重传，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。因此Rdt2.0这样的协议被称为停等协议 rdt2.0未考虑ACK和NAK分组受损的情况，这也是2.1诞生的原因 Rdt2.1：如果ACK\\NAK受损 可能导致冗余 为了处理冗余发送方对每个分组增加序列号 如果ACK\\NAK受损，发送方重传当前分组，接收方丢弃冗余分组 因为除了对的都是错的，那么可以去掉NAK，只传ACK，这样可以节省空间，这也是2.2的原理 Rdt2.2 无NAK协议，代替NAK，接收方对最后正确接收的分组发送ACK rdt2.x解决了流量控制问题，以及比特出错的情况，但是丢包情况却没有解决，这也是rdt3.0的任务 Rdt3.0是具有比特差错和丢包信道的可靠数据传输，为解决丢包问题，发送方等待ACK一段合理的时间，需要倒数计时器来解决这个问题 停等操作使得rdt3.0的效率十分低下，可以使用流水线技术来解决 流水线技术中分组丢失之后如何重传 GBN（Go-Back-N）协议：其后分组全部重传 累计ACK：收到ACK（n），则n以及之前的分组都到了 若滑动窗口大小为n,则发送方只能连续发送n个数据包，同时，窗口中未被确认的分组数不能超过n 对所有的已发送但未确认的分组统一设置一个定时器，从一次流水的最“老”分组开始计时 超时（n）,重传分组n和窗口中所有序号大于n的分组 GBN滑动窗口大小 发送端&lt;=2^k-1 接收端=1 如果收到重复的分组就丢弃重发ACK，如果有分组丢失，但是后面的分组到了，也是将这一部分丢弃，然后重发按序到达的最高序号分组的ACK SR（选择重传）协议：仅重传该分组 发送方 从上层收到ACK（n）,若n在[sendbase,sendbase+N-1]范围内，则标记n已经被接受，如果n=sendbase，则将窗口基序号推到下一个未确定序号 超时（n）:为每一个分组定义计时器，如果n超时，则重传并且重置定时器 接收方 收到n在[sendbase,sendbase+N-1]范围内，发送ACK（n） 如果收到分组不是连续的，先进行缓存 按序分组 接收方和发送方窗口都不能超过2^(k-1) TCP报文首部结构 源端口和目的端口各占2字节 序号字段占4字节，TCP连接中传送的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节在整个报文字节流中的序号 确认号字段占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 和之前不同，之前收到x号分组就发ACK（x），这里收到x号分组就发ACK（x+1）表示期待收到x+1号分组 首部长度占4bits，它指示以32bit的字为单位的TCP首部长度，若选项字段为空，TCP首部典型长度为20字节 保留字段占6bits，该字段是以后所用，目前应该置为0 URG（紧急比特）=1时，表示紧急指针字段有效，它告诉系统此报文中有紧急数据，应该尽快传送（一般不使用） ACK（确认比特）=1时，确认号字段有效，=0无效 PSH（推送比特）=1时，TCP尽快交付该报文，不等整个缓存都填满再交付 RST (复位比特)=1时，表示TCP连接中出现严重差错，必须释放连接，再重新建立连接 SYN（同步比特）=1时，这是一个连接请求或者连接接受报文 FIN（终止比特）=1时，表明此报文段的数据全部发送完毕，要求释放运输连接 窗口字段占两个字节，用来控制对方发送的数据量，单位是字节，TCP连接的一端根据设置的缓存空间大小确定自己的接受窗口大小，然后通知对方来确定对方的发送窗口的上限 校验和占两个字节，该字段检验的范围包括首部和数据两个部分，所以计算的时候，需要在TCP报文段的前面加上12字节的伪首部 紧急指针字段占2个字节，该字段指出在本报文段中的紧急数据的最后一个字号的序号 选项字段，长度可变，TCP只规定了一种选项，即最大报文长度（MSS），MSS是TCP报文中数据段的最大长度。 填充字段为了使整个首部长度是4字节的整数倍 RTT=往返时延，SampleRTT=样本RTT（忽略重传），EstimatedRTT=样本RTT的均值，DevRTT=EstimatedRTT和SampleRTT的偏差 EstimatedRTT=（1-a）* EstimatedRTT+a * SampleRTT，参考值a=0.125 DevRTT=（1-b）* DevRTT+b * |SampleRTT-EstimatedRTT|,参考值b=0.25 第一次计算的时候DevRTT=0.5*SampleRTT 产生TCP ACK的建议 接受方事件 TCP接收方动作 所期望序号的报文段按序到达，所有在期望序号及其以前的数据都已经被确认 延迟的ACK，对另一个按序报文段的到达最多等待500ms，如果下一个按序报文段还没有到达，就发送一个ACK 所期望序号的报文段按序到达，另一个按序报文段等待发送ACK 立即发送单个累计ACK，以确认两个按序报文段 比期望序号大的失序报文段到达，检测出数据流中的间隔 立即发送冗余ACK，指明下一个期待字节的序号 能部分或者完全填充接收数据间隔的报文段到达 假如该报文段起始于间隔的低端，则立即发送ACK 快速重传：接收到重复的ACK就重传，不一定非要等到规定的时间间隔 TCP通过三次握手建立连接 拥塞控制的方法 网络辅助的拥塞控制 直接网络反馈：路由器以阻塞分组的形式通知发送方网络阻塞 由接收方的网络反馈：路由器标识从发送方到接收方分组中某个字段来指示拥塞产生，由接收方通知发送方 端到端拥塞控制（目前TCP使用该方法） 网络层不为拥塞控制提供任何帮助和支持 端系统通过对网络行为（丢包或者时延增加）的观测来判断网络是否发生拥塞","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"计算机网络知识总结（一）","slug":"winnet","date":"2021-11-08T02:43:08.000Z","updated":"2021-11-11T10:28:56.957Z","comments":true,"path":"posts/de1fcd2b.html","link":"","permalink":"http://fx-zpy.github.io/posts/de1fcd2b.html","excerpt":"","text":"这里将所学的计算机网络的 课程的知识进行归纳总结，预计一篇完不成，所以分篇进行归纳总结，这是自顶向下第七版的第一章，主要是从总体介绍一下计算机网络的模型和接下来会接触到的知识。 一、计算机网络和因特网相关问题和知识点总体概述 什么是因特网 具体构成：基本硬件和软件组件， 分布式应用服务 端系统是主机，通过通信链路和分组交换机连接到一起，通过因特网服务提供商（ISP）接入因特网 主机分为客户机和服务器 当今因特网内，最著名的分组交换机为路由器和链路层交换机 端系统、分组交换机和其他部件都需要运行一系列协议，其中最重要的两个协议是TCP（传输控制协议）和IP（网际协议）。因特网的主要协议统称为TCP/IP 因特网的分布式应用程序运行在端系统上，分许交换机只是用来加速端系统之间数据交换的，不运行应用程序 端系统之间的数据交互通过套接字接口来对应交互 协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输/接收或其他事件方面采取的动作 接入网指将端系统物理连接到其边缘路由器的网络，而边缘路由器是端系统到任意其他的远程端系统的路径上的第一台路由器。接入网分为以下几种 家庭接入：DSL（数字用户线）、电缆、FTTH（光纤到户）、拨号、卫星 企业（和家庭）接入：以太网、WiFi 广域无线接入：3G（出书那年4G还没出)、LTE 物理媒体分为导引型和非导引型媒体，导引型是电波沿着固体媒体前行，例如光缆、双绞铜线、同轴电缆，非导引型是电波在空气或者外层空间中传播，例如无线局域网和数字卫星频道 通过网络链路和交换机移动数据有两种基本方法，电路交换和分组交换 分组交换：端系统之间彼此交换报文，报文比较长，源端将长报文划分为较小的数据块，每一块成为分组（packet） 输入端的机制是存储转发传输，即在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组 分组交换由于其到端时延是不可预测的，所以不适合实时服务。 分组交换提供了比电路交换更好的带宽共享；他比电路交换更简单，更有效，实现成本更低 分组交换时延类型 节点处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分，除此之外，还需要检查比特级差错。高速路由器的处理时延通常是微秒或更低的数量级 排队时延：在队列中，当分组在链路上等待传输时，产生排队时延。影响排队时延的因素有：到达该队列的流量强度和性值。实际的排队时延通常在毫秒到微秒级 传输时延：传输距离/传输速度，得到的是传输时间。这个时间就是将所有的比特推向链路所需要的时间。实际的传输时延通常在毫秒到微秒级 传播时延：当一个比特被推进链路后，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间时传播时延 调制/编码时延：量级为几十毫秒。 节点总时延：以上时延之和 电路交换 频分复用 时分复用 电路交换的效率较低，因为在静默的时候专用电路是空闲的。 流量强度：La/R,L是每个分组的长度，单位为比特，a是分组到达队列的平均速率，La是单位时间到达队列的分组总长，R是传输速率，流量强度&gt;1会造成拥塞，所以一般设计的时候流量强度不能大于1 丢包：由于队列容量有限，在队列满了以后，路由器会丢弃队尾若干分组 瞬时吞吐量：某一时刻目的主机接收到文件的速率 平均吞吐量：文件总大小/接收文件总用时 协议分层 应用层：应用层是网络应用程序及其应用层协议存留的地方。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文 HTTP（为web文档提供了请求和传送） SMTP（提供了电子邮件报文的传输） FTP（提供两个端系统之间的文件传送） 表示层（七层模型） 会话层（七层模型） 运输层：运输层提供了在应用程序端点之间传送应用报文的服务 TCP:向它的应用程序提供了面向连接的服务，这种服务包括了应用层报文向目的地取得确保传递和流量控制（即发送方和接收方的速率匹配）。并将长报文划分为短报文，并提供拥塞控制机制 UDP：向它的应用程序提供无连接服务。这是一种不提供不必要的服务的服务，不提供可靠性，没有流量控制，也没有拥塞控制 网络层：因特网的网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。源主机中的因特网运输层协议（TCP/UDP）向网络层递交运输层报文段和目的地址 IP协议：定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议 选路协议：数据报根据该路由从源传输到目的地 链路层：为了将分组从一个节点移动到路径的下一个节点，网络层必须依靠链路层的服务。特别是在每个节点，网络层将数据报传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据报上传给网络层。我们将链路层分组称为帧。链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素 以太网、wifi、点对点协议（PPP） 物理层：物理层的任务是将每一帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议与链路相关，并与链路的实际传输媒体（双绞铜线，单模光纤）有关 封装：报文从一层到另一层，另一层会加上该层的首部信息，将报文进行封装然后传送给下一层，应用层报文和运输层首部信息共同构成了运输层报文段 ，运输层报文段封装了应用层报文。运输层向网络层传递报文段，网络层增加了源和目的端系统地址等网络层首部信息，形成了网络层数据报。链路层增加自己的链路层首部信息并创建了链路层帧。每一层分组具有两种类型的字段：首部字段和有效载荷字段","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"}],"author":"fx-zpy"},{"title":"LeetCode几道dp中等题","slug":"lc","date":"2021-10-11T02:16:46.000Z","updated":"2021-10-20T13:01:01.693Z","comments":true,"path":"posts/db0f04bc.html","link":"","permalink":"http://fx-zpy.github.io/posts/db0f04bc.html","excerpt":"","text":"摆动序列题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 分析这道题和之前所做的合唱队形有点像，但是这不是求解最大增序列，而是增减交替的序列，首选还是一个一个分析，如果所给序列的长度只有一，那么返回的子序列的长度也是一，如果序列的长度超过一个，就可以使用两个变量up,down来计算上升和下降的个数，这里的增加数目是在对方的基础上进行的，因为要计算最长的子序列而不是最长增序列或者减序列。代码如下。 int wiggleMaxLength(int* nums, int numsSize){ if(numsSize&lt;2) return numsSize; int up=1; int down=1; for(int i=1;i&lt;numsSize;i++){ if(nums[i]&gt;nums[i-1]){ up=down+1; } else if(nums[i]&lt;nums[i-1]){ down=up+1; } } return (up&gt;down)?up:down; } 零钱兑换题目描述给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。 分析这是一个很经典的背包问题，背包是固定的，物品是多个的，我们只要求把背包填满就好了，这里使用动态规划，或者DFS加剪枝都可以，我使用的是DP，至于为什么不用DFS，因为不会我写完了看题解才发现可以使用这种方法，这里可以使用一个数组dp来接收局部最优解。dp[0]初始化0，其他初始化足够大的数，因为求最少的数目，我这里初始化为100000，只需要满足测试用例的要求即可。代码如下。 int coinChange(int* coins, int coinsSize, int amount){ int* dp=(int *)malloc((amount+1)*sizeof(int)); dp[0]=0; for(int i=1;i&lt;=amount;i++){ dp[i]=100000; } for(int i=1;i&lt;=amount;i++){ for(int j=0;j&lt;coinsSize;j++){ if(coins[j]&lt;=i){ dp[i]=dp[i]&lt;dp[i-coins[j]]+1?dp[i]:dp[i-coins[j]]+1; } } } return dp[amount]&gt;amount?-1:dp[amount]; } 这里也copy一下其他人的题解，关于使用DFS和BFS来求解的。实属强者，LeetCode的算法大佬太多了，膜拜。 以下为DFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: coins.sort(reverse=True) self.res = float(\"inf\") def dfs(i, num, amount): if amount == 0: self.res = min(self.res, num) return for j in range(i, len(coins)): # 剩下的最大值都不够凑出来了 if (self.res - num) * coins[j] &lt; amount: break if coins[j] &gt; amount: continue dfs(j, num + 1, amount - coins[j]) for i in range(len(coins)): dfs(i, 0, amount) return self.res if self.res != float(\"inf\") else -1 以下为BFS class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: from collections import deque queue = deque([amount]) step = 0 visited = set() while queue: n = len(queue) for _ in range(n): tmp = queue.pop() if tmp == 0: return step for coin in coins: if tmp &gt;= coin and tmp - coin not in visited: visited.add(tmp - coin) queue.appendleft(tmp - coin) step += 1 return -1 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 分析这里需要注意审题， 我刚开始读题不仔细，以为是分解成两个正整数，兴致勃勃的开始做题，不到两分钟代码就写好了，心里不禁想到，中等题就这，结果不小心瞟到了题目的要求，至少，顿时麻了，赶紧删掉了自己刚写好的代码，并且内心说了句，私密马赛。是我愚蠢了，那么重新分析，既然是至少，那么就不限制分解成2个了，但是想了想，不太好解，如果自底向上，往上也不好分析，因为这个不像之前的蜜蜂和走楼梯，后一个的问题只依赖于前一个和前两个问题的最优解。这里看了一下别人的思路，发现宝藏，一个人的思路是这样，根据数学的规律来解这道题，可以大大简化题目的复杂度，求解y=(n/x)^x的最大解，并且最大解的时候x的值为多少，最后算出来x=e的时候y最大，所以只要多分解出e得到的成绩就会越大，但是题目要求为正整数，所以从2和3中选择，这里随便取一个n实验一下，比如12=2+2+2+2+2+2=3+3+3+3,2^6=64,3^4=81，很显然，3比2具有更大的乘积，所以就将所给的n尽量分解成3,能够得到最大的乘积。代码如下。 int integerBreak(int n){ int a=1; if(n==2){ return 1; }else if(n==3){ return 2; }else if(n==4){ return 4; }else{ while(n&gt;4){ n-=3; a*=3; } return a*n; } } 总结dp的思想还是局部最优解的推进，但是可以使用数学知识来简化问题。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"}],"author":"fx-zpy"},{"title":"go实现简单群聊服务器","slug":"goqunliao","date":"2021-10-07T08:44:46.000Z","updated":"2021-10-20T12:36:04.467Z","comments":true,"path":"posts/4b92e806.html","link":"","permalink":"http://fx-zpy.github.io/posts/4b92e806.html","excerpt":"","text":"TCP群聊服务器实现之前实现了TCP服务器，可以和客户端通信，这次进行了扩展，将多个客户端的通信集中到一起，形成群聊系统，服务器的主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) type client struct { c chan string //发送数据的管道 name string //姓名 addr string //地址 } var onlinemap map[string]client //保存在线用户 var message = make(chan string) func manager() { onlinemap = make(map[string]client) for { msg := &lt;-message //如果message通道没有消息就阻塞 for _, cli := range onlinemap { cli.c &lt;- msg //遍历map，给每个成员都发送信息，相当于广播 } } } func writemsgtoclient(cli client, ac net.Conn) { for msg := range cli.c { ac.Write([]byte(msg + \"\\n\")) } } func makemsg(cli client, msg string) (buf string) { buf = \"[\" + cli.addr + \"]\" + cli.name + \":\" + msg return } func dispose(ac net.Conn) { //获取客户端的网络地址 cliaddr := ac.RemoteAddr().String() //创建一个结构体默认用户名和网络地址一样 cli := client{make(chan string), cliaddr, cliaddr} onlinemap[cliaddr] = cli //将结构体添加到map //新开一个协程，给当前客户发送信息 go writemsgtoclient(cli, ac) message &lt;- makemsg(cli, \"login\") cli.c &lt;- makemsg(cli, \"I am here\") isexit := make(chan bool) //新建协程，接受用户发送的数据 go func() { buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) if len == 0 { isexit &lt;- true fmt.Println(\"err=\", err) return } msg := string(buffer[:len-1]) if msg == \"who\" { ac.Write([]byte(\"user list:\\n\")) for _, tmp := range onlinemap { msg = tmp.addr + \":\" + tmp.name + \"\\n\" ac.Write([]byte(msg)) } } else if strings.Count(msg, \"\") &gt;= 8 &amp;&amp; msg[:6] == \"rename\" { name := strings.Split(msg, \"|\")[1] cli.name = name onlinemap[cliaddr] = cli fmt.Println(\"rename successfully\") } else { message &lt;- makemsg(cli, msg) } } }() for { select { case &lt;-isexit: delete(onlinemap, cliaddr) message &lt;- makemsg(cli, \"logout\") } } //开启循环，一直开启协程 } func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //开一个协程，转发信息 go manager() //主协程，循环阻塞等待用户连接 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) continue } go dispose(ac) } } 本次服务器开启的端口依旧是本地的4000端口，每个客户端可以修改自己的名称，默认的名称是地址，同时上线和退出都会有login和logout的提示。如果输入的是who那么就会给出当前在线的用户列表。 测试这里我单开一个窗口作为旁观者可以观看到其他人发的信息，俗称摸鱼窥屏怪。其他的我开了三个用户，分别重新命名为zpy,xsg,hs他们进行聊天。 这边hs的视角忘记截图了，不过有前两个人的视角应该就够了，这个群聊做的很简单，界面布局也没有什么设计，包括敏感词汇屏蔽和@功能实现都还没有做，后续随缘更新功能和界面，这次只是为了能够实现聊天的主题功能。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"go学习笔记之tcp服务器","slug":"gotcp","date":"2021-10-05T07:43:46.000Z","updated":"2021-10-20T12:36:56.853Z","comments":true,"path":"posts/db7cd9a0.html","link":"","permalink":"http://fx-zpy.github.io/posts/db7cd9a0.html","excerpt":"","text":"单程TCP服务器这是只接受来自客户端的一次通信就停止的服务器，也是后面并发服务器的基础知识，服务器的构成代码是用go语言编写，如下。 package main import ( \"fmt\" \"net\" ) func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } buffer := make([]byte, 4096) //分配一个4096字节的缓冲区来接收用户的数据 len, err := ac.Read(buffer) //返回数据长度和错误信息 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data=\", string(buffer[:len])) defer ac.Close() } 这里使用net里面的函数listen对本地4000端口进行监听，为啥是4000端口，其实端口号无所谓，4000端口是每次更新博客的时候本地调试的端口，因为经常能看色图博客，所以使用该端口，这里接受信息的缓冲区的大小为4096，也就是4kb，来自4000端口发送的数据大小不能超过该大小，使用的时候不会报错，但是服务器端只会截取规定缓冲区的大小，我实验过使用的大小为4的缓冲区来接受超过10个字节的数据，最后只是截取到前四个字节的数据就结束了。这里使用netcat下的一个可执行程序nc来进行数据的发送。分配好端口号之后就发送数据，同时服务器端接受到数据之后就停止了，因为本身就是一个单程的服务器。 并发服务器并发服务器支持对多个客户端进行数据的传送与接收。 服务器端服务器端的代码在之前单程服务器的基础上进行改进，增加协程来处理与客户端的交互。主体代码如下。 package main import ( \"fmt\" \"net\" \"strings\" ) func Dispose(ac net.Conn) { add := ac.RemoteAddr().String() //处理客户端的端口号 fmt.Println(add, \" connected successfully\") defer ac.Close() buffer := make([]byte, 4096) for { len, err := ac.Read(buffer) //接收客户端数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from client is\", string(buffer[:len])) //打印接收到数据 if string(buffer[:len-1]) == \"exit\" { return } ret := strings.ReplaceAll(string(buffer[:len]), \"sb\", \"**\") //将数据中的不文明词汇和谐，这里只处理了sb这个经常出现的词汇 ac.Write([]byte(ret)) //返回数据 } } func main() { //监听 listen, err := net.Listen(\"tcp\", \"127.0.0.1:4000\") //监听本地4000端口 if err != nil { fmt.Println(\"err=\", err) return } defer listen.Close() //在用户连接之前阻塞 for { ac, err := listen.Accept() if err != nil { fmt.Println(\"err=\", err) return } go Dispose(ac) } } 这里通过协程对每一个请求的客户端的数据都能进行处理，在实际工作中服务器端接收到客户端的数据之后可以进行很多处理，我这里仅仅进行了对敏感词汇sb的和谐，并把数据重新发回给客户端。上述代码的停止条件是输入exit，这里的处理仅仅适用于nc测试，因为nc测试中我们输入了exit回车之后换行也一并输入了进来，所以上述代码中判断条件为string(buffer[:len-1]) == “exit”，自编客户端程序进行测试的时候由于编写者的不同，数据的处理可能不同。需要根据实际情况进行修改。 测试nc这里我开了两个进程来测试服务器端能否实现并发，结果发现可以。输入exit客户端也能顺利的结束进程。 客户端程序这里也可以自编客户端程序进行测试，主动连接对应的端口号，对其进行数据的交互。这里我写了一个客户端程序进行测试，也是使用go语言进行编写。 package main import ( \"fmt\" \"net\" \"os\" ) func main() { //设置连接的端口号 conn, err := net.Dial(\"tcp\", \"127.0.0.1:4000\") if err != nil { fmt.Println(\"err=\", err) return } defer conn.Close() //开启协程，接收服务器端的回复 go func() { buffer := make([]byte, 4096) for { len, err := conn.Read(buffer) //读取数据 if err != nil { fmt.Println(\"err=\", err) return } fmt.Println(\"data from server is\", string(buffer[:len])) // } }() //给服务器端发送数据 se := make([]byte, 4096) for { len, err := os.Stdin.Read(se) //从键盘读取内容 if err != nil { fmt.Println(\"err=\", err) return } conn.Write(se[:len]) //将输入的信息发送给服务器 } } 测试截图如下 注意这里输入exit不能退出，因为客户端输入的时候输入回车，字符串后面会跟着两个字符，回车\\r，换行\\n，所以服务器端需要进行修改才能退出客户端程序，即将服务器端的判断条件改为string(buffer[:len-1]) == “exit”。但是这样感觉不方便，可以在测试的客户端输入条件判断一下，为exit就退出。当然这些都是小细节。 总结单程和并发区别在于是否使用了协程，本次测试也用到了脑残nc和客户端程序。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"}],"author":"fx-zpy"},{"title":"合唱队形&&过河卒","slug":"dp1","date":"2021-10-04T08:28:18.000Z","updated":"2021-10-20T13:01:39.083Z","comments":true,"path":"posts/9c48d863.html","link":"","permalink":"http://fx-zpy.github.io/posts/9c48d863.html","excerpt":"","text":"合唱队形题目描述N位同学站成一排，音乐老师要请其中的(N?K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1,2,…,K，他们的身高分别为T1,T2,…,TK。身高满足T1&lt;…Ti+1&gt;…&gt;TK(1≤i≤K)。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。输入有两行，第一行是一个整数N(2≤N≤100)，表示同学的总数。第二行有N个整数，用空格分隔，第i个整数Ti(130≤Ti≤230)是第i位同学的身高(厘米)。输出最少需要同学出列的个数。 思路第一次错误尝试第一次我的思路是每次标定一个人，从他开始依次向左和右进行筛选，如果有后一个比前一个高的情况出现，就判定前一个得出队列，当然我还没有意识到问题的严重性，连调试都没做就去提交了，结果可想而知，10个测试点就过了一个，以下是第一次的代码。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int min=150,flag,a; int t[100] = { 0 }; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); for (int j = 0; j &lt; 100; j++) { flag = 0; a = t[j]; for (int i = j; i &lt; 99; i++) { if (a &lt; t[i + 1])flag++; else a = t[i + 1]; } a = t[j]; for (int i = j; i &gt; 0; i--) { if (a &lt; t[i - 1])flag++; else a = t[i - 1]; } if (flag &lt; min)min = flag; } printf(\"%d\\n\", min); } 错误以后我自己进行了分析，发现，如果在我选定的那一个人的右边第一位是他右边最低的，而从右边第二位开始依次递减，那么我的算法就把从第二位开始的人全部踢出去了这显然不符合最少的规则，正确的是只需要把右边第一位踢出去就可以了。 第二次尝试经过分析以后，我开始转换思路，依旧选定一个人做参照，将合唱队分成两个部分，然后分别从最左边和最右边向中间求最多人的增序列，这样踢出去的人就最少，两个数组分别存储左右的最大增序列的人数，但是注意，被当做参照物的那个人算了两次，所以要减去1。代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n; int uflag,dflag; int t[100] = { 0 }; int u[100], d[100]; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;t[i]); } getchar(); u[0] = 1; d[n - 1] = 1; for (int i = 1; i &lt; n; i++) { uflag = 1; for (int j = 0; j &lt; i; j++) { if (t[i] &gt; t[j])uflag = uflag &gt; u[j] + 1 ? uflag : u[j] + 1; } u[i] = uflag; } for (int i = n - 2; i &gt;= 0; i--) { dflag = 1; for (int j = n - 1; j &gt; i; j--) { if (t[i] &gt; t[j])dflag = dflag &gt; d[j] + 1 ? dflag : d[j] + 1; } d[i] = dflag; } int max = 0; for (int i = 0; i &lt; n; i++) { if (u[i] + d[i] - 1 &gt; max) max = u[i] + d[i] - 1; } printf(\"%d\\n\",n-max); } 成功通过了OJ。 过河卒题目描述棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点(0,0)、B点(n,m)，同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。输入一行四个正整数，分别表示B点坐标和马的坐标。坐标不超过（20,20）。输出一个整数，表示所有的路径条数。 思路思路就是没有思路题目给我的第一印象就是好难啊，我把题目给的一个示例在草稿纸上人工走了一遍，但是没有思路，如果没有这匹该死的马，那将简单多了，就像之前的小蜜蜂和爬楼梯一样，但是可惜没有，一个马最多限制了九个点无法通过，有可能马的位置离边境较近，9个点中有部分不在（0,0）和（n,m）为顶点组成的矩形里面，我的初始想法是先求出所有的路径，然后把路径中包含马的控制点的路径排除，这个想法我没去实现，因为我在大脑里面过了一下，预感时空限制可能通不过OJ，于是打开了谷歌，搜索过河卒（bushi。看了别人的思路之后感觉豁然开朗，路径条数的dp还是我之前说的那样，每到每一个点的个数是上面点和左边点的个数之和，这里我用了一个二维数组，初始化都为0，将马的控制点设置为-1（之后再调整为0），每个数组元素的值就是到该点的路径条数之和，再用dp到(n,m)。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int x, y, m, n; int long long path[25][25] = { 0 }; int mx[8] = { -2,-2,-1,-1,1,1,2,2 }; int my[8] = { 1,-1,2,-2,2,-2,1,-1 }; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;x, &amp;y); getchar(); n += 1; m += 1; x += 1; y += 1; for (int i = 0; i &lt; 8; i++) { if (x + mx[i] &gt;= 1 &amp;&amp; x + mx[i] &lt;= n &amp;&amp; y + my[i] &gt;= 1 &amp;&amp; y + my[i] &lt;= m)path[x + mx[i]][y + my[i]] = -1; } path[x][y] = -1; path[1][0] = 1; for (int i = 1; i&lt;= n; i++) { for (int j = 1; j &lt;=m; j++) { if (path[i][j] == -1)path[i][j] = 0; else path[i][j] = path[i][j - 1] + path[i - 1][j]; } } printf(\"%lld\\n\", path[n][m]); return 0; } 这么简单的题目我都能卡住，我太菜了o(╥﹏╥)o，CSP危。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"},{"title":"逆向简单题之dotnetcrack","slug":"pwn-dotnetcrack","date":"2021-10-03T02:36:08.000Z","updated":"2021-10-20T12:55:29.436Z","comments":true,"path":"posts/a651b15e.html","link":"","permalink":"http://fx-zpy.github.io/posts/a651b15e.html","excerpt":"","text":"题目背景这道题是我的一个同学转了安全以后发给我让我帮忙做一下，但是其实本来我也没有接触多少逆向的知识，但是还是打算尝试一下，题目是dotnetcrack，打开可执行程序以后，弹出一个弹窗如下 尝试输入一串字符串，发现报错。 学习了一下这方面的知识以后，也是使用了一款反编译工具ILSpy将程序进行反编译，找到判断的关键代码， 如图可以发现其判断的语句是”2yyUjXprc1+2TwAbbVU6eQ==” == Encode(textBox1.Text)，显然，正确的字符串进行某种规则加密后的密文为2yyUjXprc1+2TwAbbVU6eQ==。 解法一：投机取巧已知判断条件之后，可以修改判断条件为!=，因为随机输入一串字符串，相等的概率极低，那么相反，不相等的概率极高，修改之后，随便输入只要不是正确的明文就可以弹出恭喜的弹窗，实验了一下，因为ILSpy不能直接修改代码，所以讲代码保存出来进行修改， 保存之后重新编译该文件，这样随便输入就可以弹出正确的弹窗了。 解法二：再次投机取巧由于解法一虽然可以弹出正确的弹窗，但是正确的明文却还是不知道，所以这次还是投机取巧的办法，但是能够获取明文，这里针对加密函数编写了一段解密函数。 public string Decode(string data) { string result; byte[] byte1; try { byte1 = Convert.FromBase64String(\"2yyUjXprc1+2TwAbbVU6eQ==\"); byte[] bytes = Encoding.ASCII.GetBytes(\"gctf{got\"); byte[] bytes2 = Encoding.ASCII.GetBytes(\"2niceday}\"); DESCryptoServiceProvider dESCryptoServiceProvider = new DESCryptoServiceProvider(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, dESCryptoServiceProvider.CreateDecryptor(bytes, bytes2), CryptoStreamMode.Write); cryptoStream.Write(byte1, 0, byte1.Length); cryptoStream.FlushFinalBlock(); System.Text.Encoding encoding = System.Text.Encoding.UTF8; result = encoding.GetString(memoryStream.ToArray()); } catch { result = \"\"; } return result; } 利用该解密函数正确的密文进行解密得到正确的明文，这次不修改判断逻辑，修改错误的输出为解密正确的密文得到的明文。 private void button1_Click(object sender, EventArgs e) { if (\"2yyUjXprc1+2TwAbbVU6eQ==\" == Encode(textBox1.Text)) { MessageBox.Show(\"Congratulation~!!\"); } else { MessageBox.Show(Decode(textBox1.Text)); } } textBox1.Text就是我们输入的内容，那么我们输入密文，弹出的就是正确的明文了 这样就可以得到明文内容了，是H0lyTru3EasY，这里再把明文输入就可以得到正确的提示了。 解法三：直接解密因为上个学期也学过密码学原理这门课，虽然我学的不咋地，但是还是尝试读懂了加密函数，发现这里采用了DES的CBC加密模式，并且使用了Base64进行编码，那么可以直接利用网上的解密工具，密钥从代码中可以得知是gctf{got，偏移值是2niceday}，直接进行解密也能获得明文。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}],"author":"fx-zpy"},{"title":"第一篇博客&&动态规划","slug":"dp0","date":"2021-10-02T03:43:08.000Z","updated":"2021-11-08T04:18:48.305Z","comments":true,"path":"posts/62cb98ee.html","link":"","permalink":"http://fx-zpy.github.io/posts/62cb98ee.html","excerpt":"","text":"数字三角形题目描述观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。第一个行一个正整数r,表示行的数目。后面每行为这个数字金字塔特定行包含的整数。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 思路动态规划有两种路线，这道题我选择了从底向上，用一个数组来存储每一个点的局部最大和，从倒数第二层开始，一直到顶层，最后得到的数组的第一位数就是最大值，代码如下。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int r; int num[1001] = { 0 }; scanf(\"%d\", &amp;r); getchar(); int array[1001][1001] = { 0 }; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; i || j == i; j++) { scanf(\"%d\", &amp;array[i][j]); } getchar(); } for (int j = 0; j &lt; r - 1; j++) { if (array[r-1][j] &gt; array[r-1][j + 1]) num[j] = array[r-2][j] + array[r-1][j]; else num[j] = array[r-2][j] + array[r-1][j + 1]; } for (int i = r - 3; i &gt; 0||i==0; i--) { for (int j = 0; j &lt; i || j == i; j++) { if (num[j] &gt; num[j + 1]) num[j] = num[j] + array[i][j]; else num[j] = num[j + 1] + array[i][j]; } } printf(\"%d\", num[0]); return 0; } 最后可以通过OJ平台，但是在vs调试的时候发现数组栈溢出了。 母牛的故事题目描述有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 思路通过列举前几年的关系，发现规律，前4年的数量和年份相同，第五年的时候，第二年的两头牛是成年母牛可以生殖了，所以应该是上一年的数量加上上四年的数量，因为题目给的年份不多，所以用一个55位的数组存储每一年的数量，再根据输入n的值，直接输出数组[n]。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int n; scanf(\"%d\", &amp;n); getchar(); int num[55] = { 0 }; for (int i = 1; i &lt; 55; i++) { if (i &gt; 0 &amp;&amp; i &lt; 5)num[i] = i; else num[i] = num[i-1] + num[i - 3]; } while (n != 0) { printf(\"%d\\n\", num[n]); scanf(\"%d\", &amp;n); getchar(); } return 0; } 一只小蜜蜂题目描述有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。 输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。对于每一个测试样例，输出蜜蜂从蜂房a到蜂房b的可能路线数。 思路分析可知，a比b小，从a到b直接不好分析，从b开始，能直接到b的有b-1和b-2那么路线数就是两者之和，再分析b-1和b-2，发现规律一致，也是题目便利，数据都不大，可以用数组来表示可能路线数，这里的数组下标是两者的距离。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a, b; long long int k[50] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 50; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d%d\", &amp;a, &amp;b); getchar(); printf(\"%lld\\n\", k[b - a]); } return 0; } 这里有个坑，初始我定义k的时候类型是int，但是OJ报错，查了一下资料才发现数据越界，于是改成lli就行了。 爬楼梯题目描述有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数，对于每个测试实例，请输出不同走法的数量。 思路这道题目读完以后不难发现，和小蜜蜂基本一致，只不过a固定是1罢了，数据范围还小了，直接上代码。 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n, a; long long int k[41] = { 0 }; k[1] = 1; k[2] = 2; for (int i = 3; i &lt; 41; i++) { k[i] = k[i - 1] + k[i - 2]; } scanf(\"%d\", &amp;n); getchar(); while (n--) { scanf(\"%d\", &amp;a); getchar(); printf(\"%lld\\n\", k[a-1]); } return 0; }","categories":[{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"}],"author":"fx-zpy"}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://fx-zpy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://fx-zpy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"刷题","slug":"刷题","permalink":"http://fx-zpy.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://fx-zpy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/categories/CTF/"}],"tags":[{"name":"database","slug":"database","permalink":"http://fx-zpy.github.io/tags/database/"},{"name":"知识体系","slug":"知识体系","permalink":"http://fx-zpy.github.io/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"计网","slug":"计网","permalink":"http://fx-zpy.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"DP","slug":"DP","permalink":"http://fx-zpy.github.io/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fx-zpy.github.io/tags/LeetCode/"},{"name":"GO","slug":"GO","permalink":"http://fx-zpy.github.io/tags/GO/"},{"name":"TCP","slug":"TCP","permalink":"http://fx-zpy.github.io/tags/TCP/"},{"name":"CSP","slug":"CSP","permalink":"http://fx-zpy.github.io/tags/CSP/"},{"name":"CTF","slug":"CTF","permalink":"http://fx-zpy.github.io/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"http://fx-zpy.github.io/tags/%E9%80%86%E5%90%91/"}]}